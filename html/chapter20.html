<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <base href="./">
    <title>Appendix C｜测试方法：虚时间、回放与混沌工程</title>
    <link rel="stylesheet" href="assets/style.css">
    <link rel="stylesheet" href="assets/highlight.css">
    <script src="assets/script.js" defer></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$']],
                displayMath: [['$$', '$$']],
                processEscapes: false,
                packages: {'[+]': ['noerrors', 'ams']}
            },
            options: {
                ignoreHtmlClass: 'tex2jax_ignore',
                processHtmlClass: 'tex2jax_process'
            },
            loader: {
                load: ['[tex]/noerrors', '[tex]/ams']
            }
        };
    </script>
</head>
<body>
    <div class="container">
        <nav id="sidebar" class="sidebar">
            <div class="sidebar-header">
                <h3>目录</h3>
                <button id="sidebar-toggle" class="sidebar-toggle">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
            </div>
            <div class="sidebar-search">
                <input type="text" id="sidebar-search-input" placeholder="搜索..." autocomplete="off">
            </div>
            <div id="tree-container">
                <nav class="tree-nav" role="tree">
                    <div class="tree-item " >
                        <a href="index.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">《用 FRP（Functional Reactive Programming）搭建 LLM 实时 Agent：从抽象到落地》</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter1.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 1｜问题空间与总体架构：为什么用 FRP</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter2.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 2｜FRP 基础：用事件流描述 Agent</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter3.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 3｜核心运行时：Agent 作为“可组合的反应系统”</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter4.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 4｜Prompt Management：内嵌环境状态播报 + 时间变化</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter5.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 5｜用户异步动作：打断、撤回、改口、多模态输入</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter6.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 6｜工具 / API 调用：失效处理、回退、幂等与隔离</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter7.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 7｜RAG / DB / Python toolcall：把知识管道变成事件流</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter8.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 8｜Speculative Exec & Speculative Decoding：让系统“更快也更稳”</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter9.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 9｜Dynamic Batching & 并发：吞吐、延迟与公平性</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter10.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">[Chapter 10｜事件触发器：做一个“类似 VAD”的 Agent Trigger System](chapter10.md)</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter11.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 11｜Race Condition 与一致性：并发世界的“真相维护”</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter12.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 12｜Token Budget 控制：预算就是产品体验</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter13.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 13｜日志持久化与可观测性：Tracing/Replay/Metric 一体化</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter14.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 14｜人类直观 UI（含音效）与后台 Debug 可视化</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter15.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 15｜安全、隐私与治理：让 Agent 可上线、可合规</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter16.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 16｜评测与持续迭代：从“能用”到“好用”</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter17.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 17｜参考实现：一个端到端的 FRP Agent</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter18.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Appendix A｜术语表 & FRP 算子速查 (The Agent Developer's Rosetta Stone)</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter19.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Appendix B｜数据结构与协议：Event/State/Receipt/Trace Schema</span>
                        </a>
                    </div>
                
                    <div class="tree-item active" >
                        <a href="chapter20.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Appendix C｜测试方法：虚时间、回放与混沌工程</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="CLAUDE.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Untitled</span>
                        </a>
                    </div>
                </nav>
            </div>
        </nav>
        
        <main class="content">
            <article>
                <h1 id="appendix-c">Appendix C｜测试方法：虚时间、回放与混沌工程</h1>
<h2 id="1">1. 开篇段落</h2>
<p>在构建实时 LLM Agent 时，开发者通常面临三大测试噩梦：<strong>非确定性</strong>（LLM 的输出每次可能不同）、<strong>时间依赖性</strong>（超时、去抖动、竞态条件难以复现）以及<strong>外部副作用</strong>（API 调用既慢又费钱）。传统的单元测试（Mock/Stub）往往难以覆盖复杂的异步流交互。</p>
<p>FRP 架构的最大优势之一，就是能将“时间”抽象为可操控的变量。本章将介绍如何利用 FRP 的特性建立一套坚固的测试体系：利用<strong>虚拟时间（Virtual Time）</strong>瞬间完成长时序逻辑的测试，利用<strong>事件回放（Event Replay）</strong>实现 100% 的确定性回归，以及通过<strong>流式混沌工（Stream-based Chaos）</strong>主动注入故障以验证系统的鲁棒性。</p>
<p><strong>学习目标</strong>：</p>
<ul>
<li>理解并掌握虚拟时间调度器（Virtual Scheduler）的原理与应用。</li>
<li>学会设计基于“事件日志（Event Log）”的确定性回放系统。</li>
<li>掌握如何在事件流中注入延迟、错误和乱序，进行混沌测试。</li>
<li>建立 Agent 性能基准测试的指标体系。</li>
</ul>
<hr />
<h2 id="2">2. 文字论述</h2>
<h3 id="c1-virtual-time-driven-testing">C.1 虚拟时间驱动的测试 (Virtual Time Driven Testing)</h3>
<p>在真实世界中，测试一个“用户停止输入 5 秒后触发自动保存”的逻辑，你需要真的等 5 秒。这使得测试套件运行缓慢且脆弱。</p>
<p>在 FRP 中，所有的算子（debounce, throttle, delay, interval）都依赖于一个<code>Scheduler</code>（调度器）。通过替换底层的调度器，我们可以接管时间。</p>
<h4 id="_1">概念模型：上帝视角的时间轴</h4>
<p>虚拟时间调度器就像电影剪辑软件的时间轴游标。你可以随意将游标拖动到 <code>t=5000ms</code> 的位置，而不需要实地流逝 5 秒。</p>
<div class="codehilite"><pre><span></span><code>[真实时间调度]
Wall Clock: 0s .....(waiting)..... 5s -&gt; 触发 Action
Test Time:  5s+ (测试非常慢)

[虚拟时间调度]
Logical T:  0s -&gt; (jump) -&gt; 5000ms -&gt; 触发 Action
Test Time:  &lt;1ms (瞬间完成)
</code></pre></div>

<h4 id="rule-of-thumb">Rule of Thumb: 依赖注入时间</h4>
<blockquote>
<p><strong>法则</strong>：永远不要在 Agent 的核心逻辑中直接调用 <code>System.currentTimeMillis()</code> 或 <code>setTimeout</code>。应该将 <code>Clock</code> 和 <code>Scheduler</code> 作为依赖项注入（Dependency Injection）。在生产环境注入 <code>RealScheduler</code>，在测试环境注入 <code>TestScheduler</code>。</p>
</blockquote>
<h4 id="_2">应用场景</h4>
<ol>
<li><strong>超时测试</strong>：模拟工具调用 30秒无响应，触发 fallback 逻辑。在虚拟时间中，这只是推进一步时钟。</li>
<li><strong>Debounce/Throttle 验证</strong>：精确验证用户在第 10ms、200ms、550ms 输入字符时，debounce(500ms) 到底会在哪个时刻触发。</li>
<li><strong>长周期任务</strong>：测试“每天早上 8 点发送问候”，不需要修改系统时间，只需将虚拟时钟拨动 24 小时。</li>
</ol>
<h3 id="c2-event-replay-testing">C.2 事件回放测试 (Event Replay Testing)</h3>
<p>Agent 的状态是由事件流驱动的。根据 FRP 的公式 <code>State = reduce(Events, InitialState)</code>，只要<strong>初始状态一致</strong>且<strong>事件序列一致</strong>，<strong>最终状态必然一致</strong>。这是构建“时光机”调试器的基础。</p>
<h4 id="llm">挑战：LLM 的非确定性</h4>
<p>虽然代码逻辑是确定性的，但 LLM 的输出（Effect）不是。如果直接重放用户输入，LLM 可能会生成不同的回复，导致后续逻辑分叉。</p>
<h4 id="effect-effect">解决方案：记录“Effect 结果”而非“重新执行 Effect”</h4>
<p>在录制模式下，我们需要记录两类事件：</p>
<ol>
<li><strong>Inbound Events</strong>：用户的输入、系统信号。</li>
<li><strong>Effect Completion Events</strong>：LLM 的回复、API 的返回结果、DB 的查询结果。</li>
</ol>
<p>在回放模式下，我们<strong>禁掉</strong>真实的副作用执行器（Effect Runner），改为从日志中读取“Effect Completion Events”并注入到流中。</p>
<div class="codehilite"><pre><span></span><code>[录制阶段 (Recording)]
User Input --&gt; [Logic] --&gt; Call LLM (Effect) --&gt; (Real LLM API)
                                                      |
                                                      v
Log File: [ {t:10, type:User, data:&quot;Hi&quot;}, {t:200, type:LLM_Res, data:&quot;Hello&quot;} ]

[回放阶段 (Replaying)]
Log File --&gt; [Replay Engine] --(inject t:10)--&gt; [Logic]
                                                  |
             (Skip Real API) &lt;--- [Logic] &lt;-------+
                                                  |
Log File --(inject t:200)-------------------------+-&gt; [Logic] --&gt; Verify State
</code></pre></div>

<h4 id="rule-of-thumb_1">Rule of Thumb: 边界隔离</h4>
<blockquote>
<p><strong>法则</strong>：回放测试的边界应划定在“纯逻辑”与“副作用”之间。凡是涉及 IO（网络、磁盘、随机数）的操作，在回放时都应视为“外部输入事件”进行 Mock 或重放。</p>
</blockquote>
<h3 id="c3-stream-based-chaos">C.3 混沌工程与流式故障注入 (Stream-based Chaos)</h3>
<p>分布式系统中最难调试的是<strong>部分失败</strong>和<strong>时序异常</strong>。FRP 的流式特性使得我们可以像搭积木一样，在数据流管道中插入捣乱”的算子。</p>
<h4 id="chaos-operators">常见的混沌算子 (Chaos Operators)</h4>
<ol>
<li>
<p><strong>延迟注入 (Latency Injection)</strong>：
    在工具调用的响应流上加一个 <code>delay(random(100ms, 5000ms))</code>。
    <em>目标</em>：验证 UI 是否展示 Loading 状态，竞态处理（switchLatest）是否正确丢弃了过期的包。</p>
</li>
<li>
<p><strong>异常注入 (Error Injection)</strong>：
    随机将流中的正常数据映射为 <code>Error Event</code>。
    <em>目标</em>：验证 Retry 策略（指数退避）、Circuit Breaker（熔断）以及错误提示 UI。</p>
</li>
<li>
<p><strong>乱序注入 (Reordering/Shuffling)</strong>：
    利用 buffer 收集一段时间的事件，打乱顺序后再发出。
    <em>目标</em>：验证系统是否依赖消息到达的物理顺序，是否正确使用 <code>sequenceId</code> 或逻辑时钟进行排序。</p>
</li>
<li>
<p><strong>背压风暴 (Backpressure Storm)</strong>：
    以极高频率发出事件（模拟热点点击或死循环）。
    <em>目标</em>：验证 <code>throttle</code>、<code>debounce</code> 或 Token Bucket 限流器是否生效，确保内存不泄漏。</p>
</li>
</ol>
<h3 id="c4-performance-benchmarking">C.4 能基准 (Performance Benchmarking)</h3>
<p>针对实时 Agent，性能不仅仅是 RPS（Requests Per Second），更多关乎用户体验指标。</p>
<p>| 指标 | 说明 | FRP 关注点 |</p>
<table>
<thead>
<tr>
<th style="text-align: left;">指标</th>
<th style="text-align: left;">说明</th>
<th style="text-align: left;">FRP 关注点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>TTFT (Time To First Token)</strong></td>
<td style="text-align: left;">从用户动作结束到首个字符上屏的时间</td>
<td style="text-align: left;">测量 Pipeline 中各 Stage 的耗时分布</td>
</tr>
<tr>
<td style="text-align: left;"><strong>End-to-End Latency</strong></td>
<td style="text-align: left;">完成整个任务（含工具调用）的总耗时</td>
<td style="text-align: left;">观察并发算子（merge/zip）是否有效并行化</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Token Throughput</strong></td>
<td style="text-align: left;">生成速度 (tokens/sec)</td>
<td style="text-align: left;">监控流式处理是否存在阻塞主线程的情况</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Jitter (抖动)</strong></td>
<td style="text-align: left;">响应时间的方差</td>
<td style="text-align: left;">确保 GC 或长任务不会造成 UI 卡顿（丢帧）</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="3">3. 本章小结</h2>
<ol>
<li><strong>虚拟时间</strong>是测试异步逻辑的“银弹”，它将物理时间解耦，使测试瞬间完成且结果确定。</li>
<li><strong>确定性回放</strong>要求我们将“副作用的结果”视为输入流的一部分进行录制，从而剥离 LLM 的随机性。</li>
<li><strong>混沌测试</strong>在 FRP 中非常易实现，只需在流上组合故障算子（Delay, Error, Shuffle）。</li>
<li>测试不仅是为了找 Bug，更是为了确立<strong>性能基线</strong>和<strong>一致性保证</strong>，这对于复杂的实时 Agent 至关重要。</li>
</ol>
<hr />
<h2 id="4">4. 练习题</h2>
<h3 id="_3">基础题</h3>
<p><strong>Q1. 虚拟时间的基本原理</strong>
为什么在单元测试中使用 <code>VirtualScheduler</code> 比使用 <code>sleep()</code> 或 <code>setTimeout</code> 更好？请列举至少三个理由。</p>
<p><strong>Q2. 回放与副作用</strong>
在进行回放测试时，Agent 触发了一个“查询天气”的工具调用（Tool Call）。在回放模式下，是否应该真实发送 HTTP 请求去查询天气 API？为什么？</p>
<p><strong>Q3. 混沌算子</strong>
如果你想测试 Agent 在网络极不稳定的情况下（丢包率 20%）的表现，你应该在 FRP 的哪个环节插入什么逻辑？</p>
<p><strong>Q4. 指标定义</strong>
对于一个流式输出的 Agent，为什么 TTFT (Time To First Token) 比总生成时间更影响用户的主观等待体验？</p>
<h3 id="_4">挑战题</h3>
<p><strong>Q5. 解决“当前时间”的悖论 (思题)</strong>
假设 Agent 的 Prompt 中包含：“现在是 {Current_Time}，请回答...”。
如果在 2024年1月1日 录制了一段对话，而在 2025年1月1日 进行回放测试。
如果不做处理，Prompt 中的时间变了，LLM 的回答可能完全不同（例如询问“今天是星期几”）。
请利用“依赖注入”和“Prompt Patching”的概念，设计一个方案，确保回放时 LLM 看到的“当前时间”依然是 2024年1月1日。</p>
<p><strong>Q6. 竞态条件重现</strong>
设计一个测试用例，利用虚拟时间重现以下 Bug：
用户快速发送 "A" (t=0) 和 "B" (t=100)。
LLM 针对 "A" 的处理很慢，在 t=500 返回结果。
LLM 针对 "B" 的处理很快，在 t=300 返回结果。
如果系统没有正确使用 <code>switchLatest</code>，UI 可能会先显示 B 的结果，然后被 A 的结果覆盖（错误）。
请用伪代码描述如何在测试中编排这个时序。</p>
<hr />
<h3 id="_5">练习题参考答案</h3>
<details>
<summary><strong>点击展开答案</strong></summary>
<p><strong>A1. 虚拟时间的优势</strong></p>
<ol>
<li><strong>速度</strong>：无需真实等待，测试运行速度提升数千倍。</li>
<li><strong>确定性</strong>：消除了系统负载、OS 调度导致的微小时间误差，不仅解决 flaky tests，还能精确断言毫秒级逻辑。</li>
<li><strong>可控性</strong>：可以模拟极其罕见的时序边界情况（如两个事件在同一毫秒发生）。</li>
</ol>
<p><strong>A2. 回放中的副作用</strong>
不应该。</p>
<ol>
<li><strong>确定性破坏</strong>：真实 API 返回的天气可能变了，导致 Agent 后续行为与录制时不一致，回放失败。</li>
<li><strong>成本与速度</strong>：真实调用慢且可能产生费用。</li>
<li><strong>副作用风险</strong>：如果工具是“删除文件”或“发送邮件”，回放不应再次执行破坏性操作。
应该是从日志中读取上次录制的“API 返回结果”并注入系统。</li>
</ol>
<p><strong>A3. 丢包模拟</strong>
在 Agent 接收外部信号的 Input Stream 或工具返回的 Response Stream 上，插入一个 <code>filter</code> 算子。
逻辑：<code>stream.filter(() =&gt; Math.random() &gt; 0.2)</code>。
这会随机丢弃 20% 的事件，从而测试系统的超时重试或容错机制。</p>
<p><strong>A4. TTFT 的重要性</strong>
因为 LLM 生成通常较慢。TTFT 决定了用户“感觉到系统开始响应”的时间。一旦首字出现，用户就会开始阅读，后续生成的延迟会被阅读时间掩盖。如果 TTFT 长，用户会以为系统死机或网络断开。</p>
<p><strong>A5. 冻结时间的方案</strong></p>
<ol>
<li><strong>抽象 Clock</strong>：定义一个 <code>IClock</code> 接口，包含 <code>now()</code> 方法。</li>
<li><strong>Prompt 构造</strong>：Prompt 中的时间不直接取 <code>Date.now()</code>，而是取 <code>IClock.now()</code>。</li>
<li><strong>录制时</strong>：记录下 Session 开始时的绝对时间戳 $T_0$。</li>
<li><strong>回放时</strong>：注入一个 <code>FixedClock</code> 或 <code>OffsetClock</code>，使其返回 $T_0$ (或者 $T_0 + \text{elapsed_virtual_time}$)。
这样，Prompt 里的字符串构建在回放时与录制时完全二进制一致。</li>
</ol>
<p><strong>A6. 竞态重现伪代码</strong></p>
<div class="codehilite"><pre><span></span><code>// 伪代码
setup:
  scheduler = new VirtualScheduler()
  results = []
  agent = new Agent(scheduler)
  agent.outputStream.subscribe(r =&gt; results.push(r))

test:
  // 模拟输入流
  scheduler.schedule(t=0,   () =&gt; agent.input(&quot;A&quot;))
  scheduler.schedule(t=100, () =&gt; agent.input(&quot;B&quot;))

  // 模拟 LLM 响应流 (Mock)
  // 这里的关键是：针对 A 的响应比 B 晚
  mockLLM.onRequest(&quot;A&quot;).delay(500).respond(&quot;Result A&quot;)
  mockLLM.onRequest(&quot;B&quot;).delay(200).respond(&quot;Result B&quot;) // B 会在 t=100+200=300 返回

  // 执行虚拟时间到 t=600
  scheduler.advanceTo(600)

  // 断言
  // 如果正确使用了 switchLatest，&quot;Result A&quot; 应该被丢弃或忽略
  // 最终状态应该是 &quot;Result B&quot;
  // 如果 results 包含 [&quot;Result B&quot;, &quot;Result A&quot;]，则测试失败（发生了回退）
  assert(results.last() == &quot;Result B&quot;)
  assert(!results.includes(&quot;Result A&quot;)) // 视具体实现，A 可能根本不应该推送到流中
</code></pre></div>

</details>
<hr />
<h2 id="5-gotchas">5. 常见陷阱与错误 (Gotchas)</h2>
<h3 id="1-microtasks-macrotasks">1. 混淆 Microtasks 和 Macrotasks</h3>
<p>在 JavaScript/Node.js 环境中，Promise (Microtask) 和 <code>setTimeout</code> (Macrotask) 的优先级不同。
<strong>陷阱</strong>：在使用虚拟时间调度器时，如果你的代码混合使用了 FRP 的 <code>delay</code>（通常由调度器控制）和原生的 <code>Promise.resolve</code>，可能会导致执行顺序与预期不符。
<strong>对策</strong>：尽量将所有异步操作通过 FRP 的 <code>fromPromise</code> 或 <code>observeOn(scheduler)</code> 纳管，确保统一由调度器排序。</p>
<h3 id="2_1">2. 测试中的“副作用泄漏”</h3>
<p><strong>陷阱</strong>：在编写测试时，忘记 Mock 某个日志上报接口或分析埋点。虽然测试通过了，但每次跑单元测试都会向你的分析服务器发送垃圾数据。
<strong>对策</strong>：在测试环境的 <code>teardown</code> 阶段检查是否有未被 Mock 的网络请求发出（许多测试框架提供此功能）。</p>
<h3 id="3_1">3. 随机数种子未固定</h3>
<p><strong>陷阱</strong>：Agent 内部逻辑可能使用了 <code>Math.random()</code>（例如用于负载均衡或随机问候语）。这会导致即使是回放测试也偶尔失败。
<strong>对策</strong>：在测试环境中，Mock 全局的随机数生成器，或者使用带有固定 Seed 的随机数生成器。</p>
<h3 id="4-cancellation">4. 忽略了取消（Cancellation）的验证</h3>
<p><strong>陷阱</strong>：测试往往关注“成功流程”。很容易忘记测试“用户在 LLM 输出一半时点击取消”的场景。如果不测试，可能会导致后台 goroutine/Promise 泄漏，或者 Token 预算被默默耗尽。
<strong>对策</strong>：在混沌测试中专门加入“随机取消”的机器猴子。</p>
<h3 id="5-log">5. Log 文件过大</h3>
<p><strong>陷阱</strong>：全量录制所有事件（包含每一帧的 Token 变化、每一帧的 UI 渲染事件）会导致回放日志体积爆炸。
<strong>对策</strong>：仅录制“关键帧”事件（输入、最终输出、工具回执）。中间状态可以通过重放逻辑计算得出。</p>
            </article>
            
            <nav class="page-nav"><a href="chapter19.html" class="nav-link prev">← Appendix B｜数据结构与协议：Event/State/Receipt/Trace Schema</a><a href="CLAUDE.html" class="nav-link next">Untitled →</a></nav>
        </main>
    </div>
</body>
</html>