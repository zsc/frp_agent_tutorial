<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <base href="./">
    <title>Chapter 1｜问题空间与总体架构：为什么用 FRP</title>
    <link rel="stylesheet" href="assets/style.css">
    <link rel="stylesheet" href="assets/highlight.css">
    <script src="assets/script.js" defer></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$']],
                displayMath: [['$$', '$$']],
                processEscapes: false,
                packages: {'[+]': ['noerrors', 'ams']}
            },
            options: {
                ignoreHtmlClass: 'tex2jax_ignore',
                processHtmlClass: 'tex2jax_process'
            },
            loader: {
                load: ['[tex]/noerrors', '[tex]/ams']
            }
        };
    </script>
</head>
<body>
    <div class="container">
        <nav id="sidebar" class="sidebar">
            <div class="sidebar-header">
                <h3>目录</h3>
                <button id="sidebar-toggle" class="sidebar-toggle">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
            </div>
            <div class="sidebar-search">
                <input type="text" id="sidebar-search-input" placeholder="搜索..." autocomplete="off">
            </div>
            <div id="tree-container">
                <nav class="tree-nav" role="tree">
                    <div class="tree-item " >
                        <a href="index.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">《用 FRP（Functional Reactive Programming）搭建 LLM 实时 Agent：从抽象到落地》</span>
                        </a>
                    </div>
                
                    <div class="tree-item active" >
                        <a href="chapter1.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 1｜问题空间与总体架构：为什么用 FRP</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter2.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 2｜FRP 基础：用事件流描述 Agent</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter3.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 3｜核心运行时：Agent 作为“可组合的反应系统”</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter4.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 4｜Prompt Management：内嵌环境状态播报 + 时间变化</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter5.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 5｜用户异步动作：打断、撤回、改口、多模态输入</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter6.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 6｜工具 / API 调用：失效处理、回退、幂等与隔离</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter7.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 7｜RAG / DB / Python toolcall：把知识管道变成事件流</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter8.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 8｜Speculative Exec & Speculative Decoding：让系统“更快也更稳”</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter9.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 9｜Dynamic Batching & 并发：吞吐、延迟与公平性</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter10.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">[Chapter 10｜事件触发器：做一个“类似 VAD”的 Agent Trigger System](chapter10.md)</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter11.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 11｜Race Condition 与一致性：并发世界的“真相维护”</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter12.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 12｜Token Budget 控制：预算就是产品体验</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter13.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 13｜日志持久化与可观测性：Tracing/Replay/Metric 一体化</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter14.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 14｜人类直观 UI（含音效）与后台 Debug 可视化</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter15.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 15｜安全、隐私与治理：让 Agent 可上线、可合规</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter16.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 16｜评测与持续迭代：从“能用”到“好用”</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter17.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 17｜参考实现：一个端到端的 FRP Agent</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter18.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Appendix A｜术语表 & FRP 算子速查 (The Agent Developer's Rosetta Stone)</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter19.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Appendix B｜数据结构与协议：Event/State/Receipt/Trace Schema</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter20.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Appendix C｜测试方法：虚时间、回放与混沌工程</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter21.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Appendix D｜部署与运维：配置、灰度、告警与容灾</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="CLAUDE.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Untitled</span>
                        </a>
                    </div>
                </nav>
            </div>
        </nav>
        
        <main class="content">
            <article>
                <h1 id="chapter-1-frp">Chapter 1｜问题空间与总体架构：为什么用 FRP</h1>
<h2 id="11">1.1 开篇段落：从“下棋”到“即时战略”</h2>
<p>构建一个传统的 Chatbot 就像在写一个回合制游戏（如国际象棋）：用户走一步（Input），系统思考（Processing），系统走一步（Output）。在这个模型中，时间是静止的，当系统在“思考”时，世界被冻结。</p>
<p>然而，构建一个<strong>生产级、实时的 LLM Agent</strong> 更像是开发一个即时战略游戏（RTS，如星际争霸）。
在 Agent 正在生成一段长回复的同时，后台的数据库查询可能刚刚超时，环境噪音检测器触发了 VAD（语音活动检测）信号，系统时钟跨过了整点需要触发定时任务，而用户此时失去耐心点击了“取消”按钮。</p>
<p>在这个混乱的并发界里，传统的 <code>request-response</code> 编程模式（无论是一个巨大的 <code>while</code> 循环，还是嵌套的 <code>async/await</code>）会迅速坍塌成无法维护的“面条代码”。我们需要一种数学上严谨的抽象来驯服<strong>时间</strong>和<strong>变化</strong>。</p>
<p>本章将介绍 <strong>Functional Reactive Programming (FRP)</strong> 如何作为构建实时 Agent 的“操作系统内核”，将异步事件流、状态管理和副作用编排统一在一个声明式的框架下。</p>
<h2 id="12">1.2 文字论述</h2>
<h3 id="121-agent">1.2.1 实时 Agent 的“七大工程地狱”</h3>
<p>在深入解决方案之前，我们必须痛苦地直面问题。为什么高阶 Agent 如此难写？因为如果不加抽象，以下七个问题会通过“笛卡尔积”的方式组合爆炸：</p>
<ol>
<li>
<p><strong>竞态条件 (Race Conditions) 的多维爆发</strong></p>
<ul>
<li><em>经典场景</em>：用户说“打开灯”，Agent 调用 Tool A。100ms 后用户说“不，等一下”，Agent 试图取消。但 Tool A 的网络请求已经发出。Tool A 返回时，Agent 该如何处理这个“迟到的真相”？是丢弃、报错还是回滚？</li>
<li><em>FRP 视角</em>：这是事件序列的<strong>顺序</strong>与<strong>时效性</strong>问题。</li>
</ul>
</li>
<li>
<p><strong>状态的时间相关性 (Temporal State)</strong></p>
<ul>
<li>Prompt 不是一个静态字符串。它是一个<strong>活的有机体</strong>。它包含“当前时间”（随秒变化）、“最近工具的输出”（随事件变化）、“Token 预算剩余”（随生成变化）。</li>
<li>手动拼接字符串不仅低效，而且容易导致“状态撕裂”（State Tearing，即 Prompt 的一部分认为现在是早上，另一部分却引用了晚上的数据）。</li>
</ul>
</li>
<li>
<p><strong>资源预算与流控 (Budgeting &amp; Backpressure)</strong></p>
<ul>
<li>LLM 的 Token 是昂贵的，推理是慢的。如果外部事件（如传感器数据或日志流）以 100Hz 的频率涌入，直接喂给 LLM 会瞬间耗尽预算并阻塞系统。</li>
<li>系统必须具备<strong>背压（Backpressure）</strong>机制：丢弃旧数据、采样、或合并数据。</li>
</ul>
</li>
<li>
<p><strong>异步副作用地狱 (Async Side-effect Hell)</strong></p>
<ul>
<li>Agent 需要执行 Python 代码、查询向量库、调用 API。这些操作不仅耗时，而且会失败。</li>
<li>当一个“推测性执行（Speculative Execution）”正在后台跑，而前台逻辑决定不再需要它时，如何<strong>干净地</strong>清理副作用（Kill process, Close socket, Rollback transaction）？</li>
</ul>
</li>
<li>
<p><strong>不可预测性与非确定性</strong></p>
<ul>
<li>LLM 的输出每次可能不同，外部 API 的延迟不可控。</li>
<li>这就要求系统必须具备极强的<strong>容错性</strong>和<strong>回退（Fallback）</strong>机制，而这些机制不能侵入主业务逻辑。</li>
</ul>
</li>
<li>
<p><strong>可观测性黑洞</strong></p>
<ul>
<li>当 Agent 发疯（死循环或幻觉）时，看静态日志是没有用的。你需要知道：“在 T=10.5s 时，系统的<strong>完整状态快照</strong>是什么？正在进行的流有哪些？”</li>
<li>传统日志记录的是“发生了什么”，而我们需要记录的是“因果关系链”。</li>
</ul>
</li>
<li>
<p><strong>复杂的取消语义 (Cancellation Propagation)</strong></p>
<ul>
<li>用户的一个闭嘴”指令，必须像闪电一样穿透整个系统：停止 TTS 播放、停止 LLM 生成、向 Python 解释器发送 SIGINT、取消正在排队的数据库查询。</li>
</ul>
</li>
</ol>
<h3 id="122-frp">1.2.2 为什么 FRP 是“银弹”？</h3>
<p>FRP（Functional Reactive Programming）基于两个核心数学概念：<strong>随时间变化的值（Signals）</strong> 和 <strong>离散的事件序列（Streams）</strong>。</p>
<ul>
<li>
<p><strong>声明式 vs 命令式</strong>：</p>
<ul>
<li><em>命令式</em>：<code>monitor_input()</code> -&gt; <code>if input changed</code> -&gt; <code>update_state()</code> -&gt; <code>check_condition()</code> -&gt; <code>call_api()</code>。</li>
<li><em>FRP</em>：<code>API_Call_Stream = Input_Stream.filter(condition).map(to_request)</code>。</li>
<li>我们描述<strong>数据之间的关系</strong>，而不是<strong>控制流的跳转</strong>。</li>
</ul>
</li>
<li>
<p><strong>时间的可控性</strong>：</p>
<ul>
<li>在 FRP 中，时间可以是物理时间，也可以是<strong>虚拟时间</strong>。</li>
<li>这意味着我们可以编写单元测试，在 1 毫秒内模拟 Agent 运行 24 小时的行为，或者“回放”昨晚发生的一个 Bug，且保证 100% 的确定性。</li>
</ul>
</li>
<li>
<p><strong>组合性 (Composability)</strong>：</p>
<ul>
<li>处理“重试”逻辑不需要改写业务代码，只需要在流上挂一个 <code>.retry(3)</code> 算子。</li>
<li>处理“防抖”逻辑只需要挂一个 <code>.debounce(500ms)</code>。</li>
<li>这种像乐高积木一样的组合能力，是应对复杂度的唯一解法。</li>
</ul>
</li>
</ul>
<h3 id="123">1.2.3 总体系统分层架构</h3>
<p>我们将一个完备的 FRP Agent 系统划分为四个象限。请记住这张图，后续章节将反复填充其中的细节。</p>
<div class="codehilite"><pre><span></span><code><span class="w">      </span><span class="p">[</span><span class="w"> </span><span class="n">现实世界</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">Reality</span><span class="w"> </span><span class="p">]</span><span class="w">                   </span><span class="p">[</span><span class="w"> </span><span class="n">记忆与存储</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">Persistence</span><span class="w"> </span><span class="p">]</span>
<span class="w">             </span><span class="o">|</span><span class="w">      </span><span class="o">^</span><span class="w">                                     </span><span class="o">^</span><span class="w">      </span><span class="o">|</span>
<span class="w">   </span><span class="p">(</span><span class="n">Sensors</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w">      </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">Actuators</span><span class="p">)</span><span class="w">              </span><span class="p">(</span><span class="n">Log</span><span class="o">/</span><span class="n">DB</span><span class="p">)</span><span class="w">   </span><span class="o">|</span><span class="w">      </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">Retrieval</span><span class="p">)</span>
<span class="w">             </span><span class="n">v</span><span class="w">      </span><span class="o">|</span><span class="w">                                     </span><span class="o">|</span><span class="w">      </span><span class="n">v</span>
<span class="o">+-----------------------------------------------------------------------+</span>
<span class="o">|</span><span class="w">  </span><span class="n">Layer</span><span class="w"> </span><span class="mi">1</span><span class="o">:</span><span class="w"> </span><span class="n">I</span><span class="o">/</span><span class="n">O</span><span class="w"> </span><span class="n">适配层</span><span class="w"> </span><span class="p">(</span><span class="n">Ingress</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">Egress</span><span class="p">)</span><span class="w">                               </span><span class="o">|</span>

<span class="o">|</span><span class="w">  </span><span class="n">Layer</span><span class="w"> </span><span class="mi">1</span><span class="o">:</span><span class="w"> </span><span class="n">I</span><span class="o">/</span><span class="n">O</span><span class="w"> </span><span class="n">适配层</span><span class="w"> </span><span class="p">(</span><span class="n">Ingress</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">Egress</span><span class="p">)</span><span class="w">                               </span><span class="o">|</span>
<span class="o">|-----------------------------------------------------------------------|</span>
<span class="o">|</span><span class="w">  </span><span class="o">*</span><span class="w"> </span><span class="n">UserMsgStream</span><span class="w"> </span><span class="p">(</span><span class="n">Text</span><span class="o">/</span><span class="n">Audio</span><span class="p">)</span><span class="w">   </span><span class="o">*</span><span class="w"> </span><span class="n">TimeTickStream</span><span class="w"> </span><span class="p">(</span><span class="n">Clock</span><span class="p">)</span><span class="w">              </span><span class="o">|</span>
<span class="o">|</span><span class="w">  </span><span class="o">*</span><span class="w"> </span><span class="n">SystemEventStream</span><span class="w"> </span><span class="p">(</span><span class="n">Interrupt</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">ToolResultStream</span><span class="w"> </span><span class="p">(</span><span class="n">Async</span><span class="w"> </span><span class="n">returns</span><span class="p">)</span><span class="w">   </span><span class="o">|</span>
<span class="o">|</span><span class="w">  </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">归一化为标准</span><span class="w"> </span><span class="n">Event</span><span class="w"> </span><span class="n">对象</span><span class="w"> </span><span class="o">--&gt;</span><span class="w">                                        </span><span class="o">|</span>

<span class="o">+-----------------------------------------------------------------------+</span>
<span class="w">                </span><span class="o">|</span>
<span class="w">                </span><span class="n">v</span><span class="w">  </span><span class="p">(</span><span class="n">Event</span><span class="w"> </span><span class="n">Stream</span><span class="p">)</span>
<span class="o">+-----------------------------------------------------------------------+</span>
<span class="o">|</span><span class="w">  </span><span class="n">Layer</span><span class="w"> </span><span class="mi">2</span><span class="o">:</span><span class="w"> </span><span class="n">FRP</span><span class="w"> </span><span class="n">核心运行时</span><span class="w"> </span><span class="p">(</span><span class="n">The</span><span class="w"> </span><span class="n">Brain</span><span class="p">)</span><span class="w">                                   </span><span class="o">|</span>

<span class="o">|</span><span class="w">  </span><span class="n">Layer</span><span class="w"> </span><span class="mi">2</span><span class="o">:</span><span class="w"> </span><span class="n">FRP</span><span class="w"> </span><span class="n">核心运行时</span><span class="w"> </span><span class="p">(</span><span class="n">The</span><span class="w"> </span><span class="n">Brain</span><span class="p">)</span><span class="w">                                   </span><span class="o">|</span>
<span class="o">|-----------------------------------------------------------------------|</span>
<span class="o">|</span><span class="w">  </span><span class="p">[</span><span class="w"> </span><span class="n">状态机</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">Reducers</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="o">&lt;----</span><span class="w"> </span><span class="p">(</span><span class="n">Previous</span><span class="w"> </span><span class="n">State</span><span class="p">)</span><span class="w">                         </span><span class="o">|</span>
<span class="o">|</span><span class="w">     </span><span class="p">(</span><span class="n">State</span><span class="p">,</span><span class="w"> </span><span class="n">Event</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">NewState</span><span class="w">                                        </span><span class="o">|</span>
<span class="o">|</span><span class="w">                                                                       </span><span class="o">|</span>
<span class="o">|</span><span class="w">  </span><span class="p">[</span><span class="w"> </span><span class="n">信号衍生</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">Derived</span><span class="w"> </span><span class="n">Signals</span><span class="w"> </span><span class="p">]</span><span class="w">                                       </span><span class="o">|</span>
<span class="o">|</span><span class="w">     </span><span class="n">State</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">PromptContextSignal</span><span class="w"> </span><span class="p">(</span><span class="n">实时</span><span class="w"> </span><span class="n">Prompt</span><span class="p">)</span><span class="w">                        </span><span class="o">|</span>
<span class="o">|</span><span class="w">     </span><span class="n">State</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">BudgetSignal</span><span class="w"> </span><span class="p">(</span><span class="n">实时预算</span><span class="p">)</span><span class="w">                                  </span><span class="o">|</span>
<span class="o">|</span><span class="w">                                                                       </span><span class="o">|</span>
<span class="o">|</span><span class="w">  </span><span class="p">[</span><span class="w"> </span><span class="n">决策策略</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">Policy</span><span class="w"> </span><span class="p">(</span><span class="n">LLM</span><span class="p">)</span><span class="w"> </span><span class="p">]</span><span class="w">                                          </span><span class="o">|</span>
<span class="o">|</span><span class="w">     </span><span class="n">PromptSignal</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">EventStream</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">DecisionStream</span><span class="w">                      </span><span class="o">|</span>
<span class="o">|</span><span class="w">                                                                       </span><span class="o">|</span>
<span class="o">|</span><span class="w">  </span><span class="p">[</span><span class="w"> </span><span class="n">调度器</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">Scheduler</span><span class="w"> </span><span class="p">]</span><span class="w">                                               </span><span class="o">|</span>
<span class="o">|</span><span class="w">     </span><span class="n">处理流的合并</span><span class="w"> </span><span class="p">(</span><span class="n">Merge</span><span class="p">)</span><span class="err">、</span><span class="n">竞态</span><span class="w"> </span><span class="p">(</span><span class="n">Switch</span><span class="p">)</span><span class="err">、</span><span class="n">防抖</span><span class="w"> </span><span class="p">(</span><span class="n">Debounce</span><span class="p">)</span><span class="w">                </span><span class="o">|</span>

<span class="o">+-----------------------------------------------------------------------+</span>
<span class="w">                </span><span class="o">|</span>
<span class="w">                </span><span class="n">v</span><span class="w">  </span><span class="p">(</span><span class="n">Effect</span><span class="w"> </span><span class="n">Description</span><span class="w"> </span><span class="n">Stream</span><span class="p">)</span>
<span class="o">+-----------------------------------------------------------------------+</span>
<span class="o">|</span><span class="w">  </span><span class="n">Layer</span><span class="w"> </span><span class="mi">3</span><span class="o">:</span><span class="w"> </span><span class="n">副作用执行层</span><span class="w"> </span><span class="p">(</span><span class="n">Effect</span><span class="w"> </span><span class="n">Runners</span><span class="p">)</span><span class="w">                                </span><span class="o">|</span>

<span class="o">|</span><span class="w">  </span><span class="n">Layer</span><span class="w"> </span><span class="mi">3</span><span class="o">:</span><span class="w"> </span><span class="n">副作用执行层</span><span class="w"> </span><span class="p">(</span><span class="n">Effect</span><span class="w"> </span><span class="n">Runners</span><span class="p">)</span><span class="w">                                </span><span class="o">|</span>
<span class="o">|-----------------------------------------------------------------------|</span>
<span class="o">|</span><span class="w">  </span><span class="o">*</span><span class="w"> </span><span class="n">此层不含业务逻辑</span><span class="err">，</span><span class="n">只负责执行指令并返回结果流</span><span class="w"> </span><span class="o">*</span><span class="w">                          </span><span class="o">|</span>
<span class="o">|</span><span class="w">  </span><span class="p">[</span><span class="n">LLM</span><span class="w"> </span><span class="n">Runner</span><span class="p">]</span><span class="w">  </span><span class="p">[</span><span class="n">Python</span><span class="w"> </span><span class="n">Runner</span><span class="p">]</span><span class="w">  </span><span class="p">[</span><span class="n">RAG</span><span class="w"> </span><span class="n">Fetcher</span><span class="p">]</span><span class="w">  </span><span class="p">[</span><span class="n">TTS</span><span class="w"> </span><span class="n">Player</span><span class="p">]</span><span class="w">           </span><span class="o">|</span>
<span class="o">|</span><span class="w">  </span><span class="p">(</span><span class="n">支持取消</span><span class="err">、</span><span class="n">重试</span><span class="err">、</span><span class="n">超时控制</span><span class="p">)</span><span class="w">                                             </span><span class="o">|</span>

<span class="o">+-----------------------------------------------------------------------+</span>
</code></pre></div>

<h3 id="124-the-vocabulary">1.2.4 关键抽象概念字典 (The Vocabulary)</h3>
<p>在本书中，我们将严格遵守以下术语定义：</p>
<ol>
<li>
<p><strong>Event (事件)</strong>:</p>
<ul>
<li>系统中发生的最小原子单位。必须包含 <code>id</code>, <code>timestamp</code>, <code>type</code>, <code>payload</code>。</li>
<li><em>例子</em>：<code>{ type: "USER_VOICE_CHUNK", payload: &lt;bytes&gt;, time: 1001 }</code>。</li>
</ul>
</li>
<li>
<p><strong>Stream (流)</strong>:</p>
<ul>
<li>随时间发生的一系列 <strong>Event</strong>。它是离散的。</li>
<li><em>隐喻</em>：传送带上的包裹。</li>
<li><em>典型用途</em>：用户输入、工具返回结果、错误通知。</li>
</ul>
</li>
<li>
<p><strong>Signal (信号/行为)</strong>:</p>
<ul>
<li>随时间连续变化的 <strong>值</strong>。在任何时刻进行采样（Sample），都有一个定义良好的值。</li>
<li><em>隐喻</em>：温度计的读数、水箱的水位。</li>
<li><em>典型用途</em>：当前 Token 消耗量、连接状态、构造好的 Prompt 字符串。</li>
<li><em>关键区别</em>：Stream 处理的是“变化”，Signal 处理的是“状态”。</li>
</ul>
</li>
<li>
<p><strong>Reducer (归约器)</strong>:</p>
<ul>
<li>一个纯函数 <code>(CurrentState, Event) -&gt; NextState</code>。</li>
<li>它是系统状态演变的唯一途径。它不执行副作用，只计算新状态。</li>
</ul>
</li>
<li>
<p><strong>Effect (副作用描述)</strong>:</p>
<ul>
<li>一个<strong>数据对象</strong>（Data Object），描述了“想要做什么”，而不是“正在做什么”。</li>
<li><em>例子</em>：<code>UseSearchTool(query="weather")</code> 是一个 Effect 对象。真正的 HTTP 请求由 Layer 3 执行。</li>
<li>这样做的好处是：我们可以拦截、修改、记录、甚至丢弃 Effect，而无需 mock 复杂的外部环境。</li>
</ul>
</li>
<li>
<p><strong>Subscription (订阅)</strong>:</p>
<ul>
<li>连接 Stream 和 Observer 的桥梁。</li>
<li><strong>Disposable (可丢弃资源)</strong>：每个订阅都必须返回一个“句柄”，调用该句柄可以取消订阅（切断水管）。这是处理取消逻辑的关键。</li>
</ul>
</li>
</ol>
<h3 id="125">1.2.5 范式迁移：从“对话”到“持续运行的回路”</h3>
<p>新手最容易犯的错是将 Agent 视为“请求-处理-响应”的 Web Server。
在 FRP 架构下，Agent 是一个<strong>永远运行的回路 (Infinite Loop)</strong>：</p>
<blockquote>
<p><code>Inputs</code> 驱动 <code>State</code> 更新，<code>State</code> 驱动 <code>Prompt</code> 变化，<code>Prompt</code> 驱动 <code>LLM</code> 产生 <code>Effect</code>，<code>Effect</code> 的执行结果变回 <code>Inputs</code>。</p>
</blockquote>
<p>这个回路在一秒钟内可能运转数十次（处理音频帧），也可能在等待用户时休眠。但<strong>架构本身是不阻塞的</strong>。</p>
<hr />
<h2 id="13">1.3 本章小结</h2>
<ul>
<li><strong>痛点</strong>：实时 Agent 面临竞态、时变状态、资源限制和异步副作用的复杂交织。</li>
<li><strong>解法</strong>：FRP 提供了一套基于时间流的数学抽象，取代了脆弱的回调和锁。</li>
<li><strong>架构</strong>：输入归一化 (Ingress) -&gt; 纯逻辑变换 (Runtime) -&gt; 副作用执行 (Runners)。</li>
<li><strong>核心对象</strong>：Stream（离散事件）、Signal（连续状态）、Reducer（状态更新逻辑）、Effect（副作用意图）。</li>
<li><strong>心智模型</strong>：不要思考“第一步做什么，第二步做什么”，要思考当数据流过管道时，如何变换它”。</li>
</ul>
<hr />
<h2 id="14">1.4 练习题</h2>
<h3 id="_1">基础题 (熟悉材料)</h3>
<p><strong>Q1. Stream vs Signal 辨析</strong>
请判断以下场景应该建模为 Stream 还是 Signal，并简述理由。</p>
<ol>
<li><strong>Token 计数器</strong>：记录当前会话总共消耗了多少 Token。</li>
<li><strong>特定的按键按下</strong>：用户按下了 "Esc" 键。</li>
<li><strong>网络连接质量</strong>：当前是 "4G", "WiFi", 还是 "Offline"。</li>
<li><strong>LLM 吐出的每一个字</strong>：生成过程中的 chunks。</li>
</ol>
<details>
<summary>点击查看参考答案</summary>
<ol>
<li><strong>Signal</strong>。这是一个随时间累积的状态值，任何时刻问“现在用了多少？”都有答案。</li>
<li><strong>Stream</strong>。这是离散的、瞬时的事件。如果在这一秒没按，就没有值。</li>
<li><strong>Signal</strong>。这是一个持续存在的环境状态。</li>
<li><strong>Stream</strong>。这是一系列离散的数据包序列，生成结束后流就完成了（Complete）。</li>
</ol>
</details>
<p><strong>Q2. 纯函数 Reducer</strong>
假设当前状态是 <code>Context { conversation_history: [], is_speaking: false }</code>。
发生了一个事件 <code>Event { type: "USER_START_TALKING" }</code>。
请写出一个符合 FRP 规范的伪代码 Reducer。如果在 Reducer 里写 <code>player.stop()</code> 会有什么问题？</p>
<details>
<summary>点击查看参考答案</summary>
<p><strong>伪代码 Reducer:</strong></p>
<div class="codehilite"><pre><span></span><code>function reducer(state, event) {
  if (event.type == &quot;USER_START_TALKING&quot;) {
    // 返回一个新的状态副本，不要修改原对象
    return {
      ...state,
      is_speaking: true, // 标记状态，但不执行动作
      interrupt_trigger: true // 可以设置一个标记位
    };
  }
  return state;
}
</code></pre></div>

<p><strong>问题</strong>：如果在 Reducer 里直接调用 <code>player.stop()</code>，这就不再是纯函数了。</p>
<ol>
<li><strong>不可测试</strong>：必须 Mock 播放器才能测试状态逻辑。</li>
<li><strong>不可回放</strong>：重放日志时，播放器会真的停止，这可能是副作用。</li>
<li><strong>竞态</strong>：Reducer 运行极其频繁，副作用执行应该由下游的 Effect Runner 专门处理（比如通过监听 <code>is_speaking</code> 号的变化来触发停止）。</li>
</ol>
</details>
<p><strong>Q3. 架构定位</strong>
你在 Layer 3 (Effect Runners) 发现了一个 Bug：Python 代码执行超时没有抛出异常，而是卡死了。你应该在 Layer 2 (Runtime) 修复它，还是 Layer 3？为什么？</p>
<details>
<summary>点击查看参考答案</summary>
<p>应该在 <strong>Layer 3</strong> 修复。
Layer 3 负责封装副作用的“物理执行细节”，包括超时机制、进程隔离、异常捕获。
Layer 2 只负责发出“请执行代码”的指令，并期望收到“成功”或“失败”的事件流。Layer 2 不应该知道 Python 解释器是如何被管理的。</p>
</details>
<h3 id="_2">挑战题 (开放性思考)</h3>
<p><strong>Q4. "时光机" 调试设计</strong>
为了实现类似 Redux DevTools 的“时间旅行”调试（拖动进度条查看 Agent 在过去某一刻的状态），根据本章的架构，你需要持久化保存哪些数据？只需要保存 State 吗？</p>
<details>
<summary>点击查看提示与答案</summary>
<p><strong>提示</strong>：State 是计算出来的结果，Input 是源头。</p>
<p><strong>答案</strong>：
只需要保存 <strong>初始状态 (Initial State)</strong> 和 <strong>Ingress 层的所有输入 Event Stream (带时间戳)</strong>。
只要有这两样东西，配合确定性的 Reducer 和逻辑，我们就可以从头重新计算出任何时刻的 State。
<em>优化</em>：为了性能，可以每隔 N 个事件保存一个 State 快照 (Snapshot)，回放时从最近的快照开始计算。
单纯保存历史 State 列表也是一种方法，但它无法重现“为什么变为这个状态”的逻辑路径，且体积可能很大。</p>
</details>
<p><strong>Q5. 竞态条件：SwitchLatest 算子</strong>
场景：</p>
<ol>
<li>用户输入 "查询 A" -&gt; 触发 Search(A)。</li>
<li>用户输入 "查询 B" -&gt; 触发 Search(B)。</li>
<li>Search(B) 先返回结果。</li>
<li>Search(A) 后返回结果。</li>
</ol>
<p>如果不做处理，界面可能会先显示 B 的结果，然后突然闪烁成 A 的结果（错误的旧数据）。
在 FRP 中，<code>switchLatest</code> (或 <code>switchMap</code>) 算子如何解决这个问题？请描述其内部机。</p>
<details>
<summary>点击查看参考答案</summary>
<p><code>switchLatest</code> 的机制是：<strong>只保留最新的“流的流”</strong>。
当“触发 Search(B)”这个事件发生并生成了一个新的 Promise/Stream 时，<code>switchLatest</code> 会自动<strong>取消订阅 (Unsubscribe)</strong> 之前的 Search(A) 流。
这意味着：</p>
<ol>
<li>如果 Search(A) 还在请求中，它会被取消（abort request）。</li>
<li>如果 Search(A) 已经返回但还在管道中排队，它的结果会被丢弃，因为下游已经切换到了 B 的频道。
这保证了输出永远对应最后一次输入。</li>
</ol>
</details>
<p><strong>Q6. Prompt 作为 Signal</strong>
如果我们将 Prompt 视为一个随时间变化的 Signal。
假设 Prompt 模板包含这句话：<code>"现在时间是 {CurrentTime}。"</code>
如果 <code>CurrentTime</code> 每秒更新一次，Prompt Signal 也会每秒更新一次。
这是否意味着我们每秒都要把巨大的 Prompt 发送给 LLM？如何优化？</p>
<details>
<summary>点击查看参考答案</summary>
<p><strong>绝对不是</strong>。这正是 FRP  <strong>Derived Signal (衍生信号)</strong> 和 <strong>Sampling (采样)</strong> 的概念。</p>
<ol>
<li>虽然 Prompt Signal 每秒都在变，但 LLM 调用是一个<strong>离散的 Event</strong>。</li>
<li>只有当需要调用 LLM 时（例如收到用户消息，或触发了任务），我们才对 Prompt Signal 进行<strong>采样 (Sample)</strong>，获取它在那一瞬间的值。</li>
<li>此外，还可以使用 <code>distinctUntilChanged</code> 算子，如果时间的精度只需要到“分钟”，那么在同一分钟内的秒数变化不会触发 Prompt Signal 的下游更新。</li>
</ol>
</details>
<hr />
<h2 id="15-gotchas">1.5 常见陷阱与错误 (Gotchas)</h2>
<ol>
<li>
<p><strong>命令式思维残留</strong></p>
<ul>
<li><em>错误</em>：在 Stream 的 <code>.map()</code> 函数里直接写 <code>DB.save(data)</code>。</li>
<li><em>后果</em>：这是在“纯变换”过程中夹带私货（副作用）。这会导致测试困难，且如果流被多次订阅，数据库会被写入多次。</li>
<li><em>修正</em>：<code>.map()</code> 应该返回一个 <code>SaveEffect</code> 对象，由后续的 Effect Runner 统一处理。</li>
</ul>
</li>
<li>
<p><strong>忽视“热”流 (Hot Observable) 的资源泄漏</strong></p>
<ul>
<li><em>错误</em>：订阅了一个无限的事件流（如时钟滴答或麦克风），但在组件销毁或用户断开时忘记 <code>unsubscribe</code>。</li>
<li><em>后果</em>：内存泄漏，后台跑着无数个僵尸任务，CPU 飙升。</li>
<li><em>Rule-of-Thumb</em>：在 FRP 中，<strong>创建订阅是责任，销毁订阅是义务</strong>。尽量使用框架提供的 <code>takeUntil(destroyStream)</code> 模式自动管理生命周期。</li>
</ul>
</li>
<li>
<p><strong>过度设计的 Reducer</strong></p>
<ul>
<li><em>错误</em>：试图把所有东西都塞进一个巨大的全局 State Reducer。</li>
<li><em>后果</em>：性能下降，任何微小的 UI 变动都触发整个状态树的重绘。</li>
<li><em>修正</em>：状态应该分层。UI 的临时状态（如输入框的高亮）不需要进入 Agent 的核心记忆（Memory）。</li>
</ul>
</li>
<li>
<p><strong>混淆 Event 和 Effect</strong></p>
<ul>
<li><em>错误</em>：把 <code>LogEvent</code> (发生了日志) 和 <code>WriteLogEffect</code> (去写日志) 混为一谈。</li>
<li><em>修正</em>：Event 是“过去时”（Fact），Effect 是“将来时”（Intent）。Event 驱动 State，State 驱动 Effect。</li>
</ul>
</li>
</ol>
            </article>
            
            <nav class="page-nav"><a href="index.html" class="nav-link prev">← 《用 FRP（Functional Reactive Programming）搭建 LLM 实时 Agent：从抽象到落地》</a><a href="chapter2.html" class="nav-link next">Chapter 2｜FRP 基础：用事件流描述 Agent →</a></nav>
        </main>
    </div>
</body>
</html>