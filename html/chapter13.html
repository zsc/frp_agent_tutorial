<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <base href="./">
    <title>Chapter 13｜日志持久化与可观测性：Tracing/Replay/Metric 一体化</title>
    <link rel="stylesheet" href="assets/style.css">
    <link rel="stylesheet" href="assets/highlight.css">
    <script src="assets/script.js" defer></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$']],
                displayMath: [['$$', '$$']],
                processEscapes: false,
                packages: {'[+]': ['noerrors', 'ams']}
            },
            options: {
                ignoreHtmlClass: 'tex2jax_ignore',
                processHtmlClass: 'tex2jax_process'
            },
            loader: {
                load: ['[tex]/noerrors', '[tex]/ams']
            }
        };
    </script>
</head>
<body>
    <div class="container">
        <nav id="sidebar" class="sidebar">
            <div class="sidebar-header">
                <h3>目录</h3>
                <button id="sidebar-toggle" class="sidebar-toggle">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
            </div>
            <div class="sidebar-search">
                <input type="text" id="sidebar-search-input" placeholder="搜索..." autocomplete="off">
            </div>
            <div id="tree-container">
                <nav class="tree-nav" role="tree">
                    <div class="tree-item " >
                        <a href="index.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">《用 FRP（Functional Reactive Programming）搭建 LLM 实时 Agent：从抽象到落地》</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter1.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 1｜问题空间与总体架构：为什么用 FRP</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter2.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 2｜FRP 基础：用事件流描述 Agent</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter3.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 3｜核心运行时：Agent 作为“可组合的反应系统”</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter4.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 4｜Prompt Management：内嵌环境状态播报 + 时间变化</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter5.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 5｜用户异步动作：打断、撤回、改口、多模态输入</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter6.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 6｜工具 / API 调用：失效处理、回退、幂等与隔离</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter7.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 7｜RAG / DB / Python toolcall：把知识管道变成事件流</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter8.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 8｜Speculative Exec & Speculative Decoding：让系统“更快也更稳”</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter9.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 9｜Dynamic Batching & 并发：吞吐、延迟与公平性</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter10.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">[Chapter 10｜事件触发器：做一个“类似 VAD”的 Agent Trigger System](chapter10.md)</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter11.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 11｜Race Condition 与一致性：并发世界的“真相维护”</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter12.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 12｜Token Budget 控制：预算就是产品体验</span>
                        </a>
                    </div>
                
                    <div class="tree-item active" >
                        <a href="chapter13.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 13｜日志持久化与可观测性：Tracing/Replay/Metric 一体化</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter14.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 14｜人类直观 UI（含音效）与后台 Debug 可视化</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter15.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 15｜安全、隐私与治理：让 Agent 可上线、可合规</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter16.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 16｜评测与持续迭代：从“能用”到“好用”</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter17.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 17｜参考实现：一个端到端的 FRP Agent</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter18.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Appendix A｜术语表 & FRP 算子速查 (The Agent Developer's Rosetta Stone)</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter19.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Appendix B｜数据结构与协议：Event/State/Receipt/Trace Schema</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter20.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Appendix C｜测试方法：虚时间、回放与混沌工程</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter21.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Appendix D｜部署与运维：配置、灰度、告警与容灾</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="CLAUDE.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Untitled</span>
                        </a>
                    </div>
                </nav>
            </div>
        </nav>
        
        <main class="content">
            <article>
                <h1 id="chapter-13tracingreplaymetric">Chapter 13｜日志持久化与可观测性：Tracing/Replay/Metric 一体化</h1>
<blockquote>
<p><strong>开篇</strong></p>
<p>在构建实时 LLM Agent 时，我们面临着传统后端从未有过的调试噩梦：</p>
<ul>
<li><strong>非确定性</strong>：同样的 Prompt 输入，LLM 可能产生不同的输出。</li>
<li><strong>异步并发</strong>：用户在说话，RAG 在检索，工具在执行，UI 在渲染，这四件事可能同时发生。</li>
<li><strong>状态复杂性</strong>：Bug 往往不是“代码崩溃”，而是“Agent 在第 5 轮对话时忘记了第 1 轮设定的约束”。</li>
</ul>
<p>传统的 "Printf Debugging" 或简单的错误日志在这里毫无意义。你需要的是一个<strong>“时空胶囊”</strong>。</p>
<p>本章将利用 FRP 的核心特性——<strong>流的不可变性（Immutability）</strong>与<strong>副作隔离（Effect Isolation）</strong>，构建一套集 <strong>结构化日志（Logging）</strong>、<strong>分布式链路追踪（Tracing）</strong> 和 <strong>确定性回放（Deterministic Replay）</strong> 于一体的可观测性系统。</p>
<p>我们的终极目标是：<strong>当线上出现 Bug，开发者可以下载日志文件，在本地 IDE 中按下一键，Agent 就像录像带倒带一样，在本地精确复现当时的每一帧状态。</strong></p>
</blockquote>
<hr />
<h2 id="131-agent">13.1 日志的对象模型：解构 Agent 的生命周期</h2>
<p>在 FRP 架构中，我们需要记录的不再是散乱的文本，而是<strong>五类核心对象</strong>。这五类对象构成了 Agent 运行的完整全息图。</p>
<h3 id="1-event">1. Event (不可变的事实)</h3>
<p>外部世界输入系统的所有信息。它们是系统的“驱动源”。</p>
<ul>
<li><strong>User Events</strong>: 文本输入、语音片段、按钮点击、中断信号。</li>
<li><strong>System Events</strong>: 时钟 Tick、网络状态变更、配置热更新。</li>
<li><strong>Callback Events</strong>: 第三方 API 的异步回调（Webhook）。</li>
</ul>
<h3 id="2-state-snapshot">2. State Snapshot (系统的记忆)</h3>
<p><code>State = scan(reducer, initial, EventStream)</code>。
每当 Event 被处理，State 就会更新。我们需要记录关键节点的<strong>状态快照（Snapshot）</strong>或<strong>增量差异（Diff）</strong>。</p>
<ul>
<li>包含：对话历史（ChatHistory）、Prompt 缓冲区、当前激活的工具、Token 消耗计数器。</li>
</ul>
<h3 id="3-effect">3. Effect (系统的意图)</h3>
<p>这是 FRP 纯逻辑层计算出的“副作用请求”。<strong>注意：记录 Effect 意图，不等于记录 Effect 结果。</strong></p>
<ul>
<li>例子：<code>{ type: "LLM_REQ", prompt: "...", temp: 0.7 }</code> 或 <code>{ type: "TOOL_CALL", name: "search", query: "..." }</code>。</li>
</ul>
<h3 id="4-effect-result">4. Effect Result (外界的反馈)</h3>
<p>这是副作用执行后返回的数据。在我们的模型中，Result 本质上也是一种 <strong>Event</strong>，通常被回注到流中。</p>
<ul>
<li>例子：<code>{ type: "LLM_RESP", text: "你好", tokens: 15 }</code> 或 <code>{ type: "TOOL_ERR", code: 500 }</code>。</li>
</ul>
<h3 id="5-span">5. Span (时间跨度)</h3>
<p>用于性能分析的操作区间。</p>
<ul>
<li>包含：<code>trace_id</code>, <code>span_id</code>, <code>start_time</code>, <code>end_time</code>, <code>status</code>, <code>attributes</code>。</li>
</ul>
<hr />
<h2 id="132-schema">13.2 结构化日志 Schema 设计</h2>
<p>为了实现自动化分析，日志必须严格结构化。以下是生产级的 Schema 建议（基于 JSON Lines 或 Protobuf）。</p>
<h3 id="the-envelope">通用信封 (The Envelope)</h3>
<p>所有日志记录共享的外层结构。</p>
<div class="codehilite"><pre><span></span><code><span class="p">{</span>
<span class="w">  </span><span class="nt">&quot;ver&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;1.0&quot;</span><span class="p">,</span><span class="w">                  </span><span class="c1">// Schema 版本，用于向后兼容</span>
<span class="w">  </span><span class="nt">&quot;ts_phy&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">1715000000123</span><span class="p">,</span><span class="w">       </span><span class="c1">// 物理时间戳 (Wall Time)</span>
<span class="w">  </span><span class="nt">&quot;ts_log&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">4501</span><span class="p">,</span><span class="w">                </span><span class="c1">// 逻辑时钟/序列号 (Logical Clock)，绝对递增</span>
<span class="w">  </span><span class="nt">&quot;trace_id&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;req-xyz-999&quot;</span><span class="p">,</span><span class="w">     </span><span class="c1">// 全链路 ID (Session ID or Request ID)</span>
<span class="w">  </span><span class="nt">&quot;span_id&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;span-abc-111&quot;</span><span class="p">,</span><span class="w">     </span><span class="c1">// 当前操作 ID</span>
<span class="w">  </span><span class="nt">&quot;parent_id&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;span-abc-000&quot;</span><span class="p">,</span><span class="w">   </span><span class="c1">// 父操作 ID</span>
<span class="w">  </span><span class="nt">&quot;kind&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;EVENT | STATE | EFFECT | SPAN_END&quot;</span><span class="p">,</span><span class="w"> </span>
<span class="w">  </span><span class="nt">&quot;payload&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="err">...</span><span class="w"> </span><span class="p">}</span><span class="w">             </span><span class="c1">// 具体业务数据</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="payload">关键 Payload 定义</h3>
<h4 id="1-event-payload">(1) Event Payload (输入)</h4>
<div class="codehilite"><pre><span></span><code><span class="p">{</span>
<span class="w">  </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;USER_AUDIO_CHUNK&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;data_ref&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;s3://logs/audio/chunk_4501.pcm&quot;</span><span class="p">,</span><span class="w"> </span><span class="c1">// 大数据存引用</span>
<span class="w">  </span><span class="nt">&quot;duration_ms&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">200</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;vad_score&quot;</span><span class="p">:</span><span class="w"> </span><span class="mf">0.95</span>
<span class="p">}</span>
</code></pre></div>

<h4 id="2-effect-payload">(2) Effect Payload (意图)</h4>
<div class="codehilite"><pre><span></span><code><span class="p">{</span>
<span class="w">  </span><span class="nt">&quot;target&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;LLM_Service&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;action&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;completion&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;params_hash&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;a1b2c3d4&quot;</span><span class="p">,</span><span class="w"> </span><span class="c1">// 用于快速比对</span>
<span class="w">  </span><span class="nt">&quot;body_snapshot&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">         </span><span class="c1">// 完整记录 Prompt，这是 Debug 的关键！</span>
<span class="w">    </span><span class="nt">&quot;messages&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="err">...</span><span class="p">],</span>
<span class="w">    </span><span class="nt">&quot;temperature&quot;</span><span class="p">:</span><span class="w"> </span><span class="mf">0.5</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<h4 id="3-tool-receipt">(3) Tool Receipt (回执)</h4>
<div class="codehilite"><pre><span></span><code><span class="p">{</span>
<span class="w">  </span><span class="nt">&quot;tool_name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;weather_api&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;input_args&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="nt">&quot;city&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Beijing&quot;</span><span class="p">},</span>
<span class="w">  </span><span class="nt">&quot;output_raw&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;{\&quot;temp\&quot;: 22}&quot;</span><span class="p">,</span><span class="w"> </span><span class="c1">// 原始回包</span>
<span class="w">  </span><span class="nt">&quot;latency_ms&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">450</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;is_cache_hit&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span>
<span class="p">}</span>
</code></pre></div>

<blockquote>
<p><strong>Rule of Thumb</strong>: <strong>不要只记结果，要记“导致结果的原因”。</strong>
对于 LLM 调用，必须记录完整的 Prompt（包含 System Prompt 和 History）。很多时候 Bug 是因为 Context 截断算法把关键信息截丢了，只看 Output 是看不出来的。</p>
</blockquote>
<hr />
<h2 id="133-frp">13.3 分布式追踪：跨越 FRP 的异步流</h2>
<p>在微服务中，Trace Context 通过 HTTP Header 传递。在 FRP 内存流中，Context 需要在 Operator 之间传递。</p>
<h3 id="_1">难点：流的合并与竞态</h3>
<p>当 <code>Stream A</code>（用户输入）和 <code>Stream B</code>（定时器）合并时，下游的 Trace Context 应该算谁的？</p>
<h3 id="context-propagation-rules">解决方案：Context Propagation Rules</h3>
<ol>
<li><strong>Event 携带 Context</strong>：每个 Event 对象内部必须携带 <code>trace_id</code> 和 <code>span_context</code>。</li>
<li><strong>Map/Filter 透传</strong>：<code>stream.map(e =&gt; process(e))</code> 输出的新事件自动继承输入事件的 Context。</li>
<li><strong>Merge 竞争</strong>：<code>merge(streamA, streamB)</code>。谁触发了这次更新，下游就继承谁的 Context。</li>
<li><strong>CombineLatest 混合</strong>：当 A 和 B 结合产生 C 时，C 的 Context 通常继承自 <strong>"主驱动方" (Primary Driver)</strong>，或者创建一个新的 Span <code>link</code> 到 A 和 B。</li>
<li><strong>SwitchLatest 截断</strong>：<ul>
<li>这是 FRP 中最需要关注的。</li>
<li>当新流切断旧流时，必须显式记录旧流的 <strong><code>Span Cancelled</code></strong> 事件。</li>
<li>统计指标时，要计算 <strong>"Wasted Time"</strong>（被 Cancel 的 Span 耗时）。</li>
</ul>
</li>
</ol>
<p><strong>ASCII 视图：流式链路追踪</strong></p>
<div class="codehilite"><pre><span></span><code>[User Input] --(Trace: T1)--&gt; [ Debounce ] --(T1)--&gt; [ LLM Request Start ]
                                   |
(User types again before 500ms)    X (Cancel T1) --&gt; [ Log: Span T1 Dropped ]
                                   |
[User Input] --(Trace: T2)--&gt; [ Debounce ] --(T2)--&gt; [ LLM Request Start ] ...
</code></pre></div>

<hr />
<h2 id="134-replaythe-time-machine">13.4 Replay：确定性回放（The Time Machine）</h2>
<p>这是本章的核心。FRP 架构如果设计得当，"Debug" = "Replay"。</p>
<h3 id="dependency-injection-event-sourcing">原理：Dependency Injection + Event Sourcing</h3>
<p>Agent 的核心逻辑是纯函数：<code>NextState = f(CurrentState, Event)</code>。
只要我们能重现 <code>Event</code> 序列，就能重现 <code>State</code> 变迁。</p>
<h3 id="_2">实施步骤</h3>
<h4 id="1-isolation">1. 隔离副作用 (Isolation)</h4>
<p>代码中严禁出现以下直接调用：</p>
<ul>
<li><code>new Date()</code> / <code>Date.now()</code></li>
<li><code>Math.random()</code></li>
<li><code>fetch()</code> / <code>db.query()</code></li>
</ul>
<p><strong>必须</strong> 抽象为接口，通过 <code>Environment</code> 注入：</p>
<ul>
<li><code>env.clock.now()</code></li>
<li><code>env.random.next()</code></li>
<li><code>env.tools.call()</code></li>
</ul>
<h4 id="2-mock-the-replay-driver">2. Mock 执行器 (The Replay Driver)</h4>
<p>在回放模式下，我们将真实的 <code>Environment</code> 替换为 <code>ReplayEnvironment</code>。</p>
<ul>
<li><strong>Time</strong>: 读日志中的 <code>ts_log</code>，快进式地推进虚拟时间。</li>
<li><strong>API Calls</strong>: 当 Agent 发起 Effect（如查询天气）时，ReplayEnv <strong>不发网络请求</strong>，而是去日志里查找：<em>“在逻辑时间 4501，是否有 tool_name='weather' 的 Receipt？”</em><ul>
<li>如果有，直接返回日志里记录的 Result。</li>
<li>如果没有（可能是代码逻辑改了，导致发起了新的请求），抛出 <code>ReplayDivergenceError</code>（回放偏离错误）。</li>
</ul>
</li>
</ul>
<h4 id="3">3. 状态重建验证</h4>
<p>回放结束后，对比回放生成的最终 State Hash 与日志中记录的 State Hash。如果一致，说明逻辑复现成功。</p>
<blockquote>
<p><strong>Rule of Thumb</strong>: <strong>随机性必须被记录。</strong>
如果使用了 <code>temperature &gt; 0</code>，LLM 的输出是随机的。回放时，我们<strong>不应该</strong>重新调用 LLM（即使是 Mock），而是直接使用日志中记录的 <code>Completion Text</code> 作为 Mock 的返回值。这样才能保证我们在调试“当时那个幻觉”，而不是生成一个新的幻觉。</p>
</blockquote>
<hr />
<h2 id="135-agent">13.5 指体系：Agent 特有的健康度</h2>
<p>除了 CPU/RAM，我们需要关注以下三类指标。</p>
<h3 id="1-quality-ux">1. 质量与体验 (Quality &amp; UX)</h3>
<ul>
<li><strong>Interruption Rate</strong>: 用户打断 Agent 发言的频率。高频率通常意味着 Agent 啰嗦或反应慢。</li>
<li><strong>Sentiment Drift</strong>: 用户情绪在对话前后的变化（需轻量级 NLP 模型打分）。</li>
<li><strong>Correction Ratio</strong>: 用户紧接着发出 "不对"、"错了" 或撤回消息的比例。</li>
</ul>
<h3 id="2-performance">2. 性能与流式特性 (Performance)</h3>
<ul>
<li><strong>TTFT (Time To First Token)</strong>: 首字延迟。</li>
<li><strong>Token Generation Rate</strong>: 生成速度 (tokens/sec)。</li>
<li><strong>E2E Latency</strong>: 意图完成总耗时。</li>
<li><strong>Frozen Time</strong>: UI 没有任何更新的最长间隔（检测卡顿）。</li>
</ul>
<h3 id="3-cost-efficiency">3. 成本与效率 (Cost &amp; Efficiency)</h3>
<ul>
<li><strong>Token Utilization</strong>: <code>Useful Output Tokens</code> / <code>Total Input Tokens</code>。</li>
<li><strong>Speculative Wasted Rate</strong>: 投机执行（Speculative Execution）产生的 Token 被丢弃的比例。如果该比例 &gt; 50%，说明投机策略过于激进。</li>
<li><strong>Cache Hit Rate</strong>: Embedding 缓存或 RAG 结果缓存的命中率。</li>
</ul>
<hr />
<h2 id="136">13.6 日志持久化策略与隐私</h2>
<h3 id="tiered-storage">采样与分级 (Tiered Storage)</h3>
<p>| 数据类型 | 采样率 | 存储位置 | 保留期 | 用途 |</p>
<table>
<thead>
<tr>
<th style="text-align: left;">数据类型</th>
<th style="text-align: left;">采样率</th>
<th style="text-align: left;">存储位置</th>
<th style="text-align: left;">保留期</th>
<th style="text-align: left;">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>Metrics</strong> (Counter/Gauge)</td>
<td style="text-align: left;">100%</td>
<td style="text-align: left;">Prometheus/Datadog</td>
<td style="text-align: left;">1年+</td>
<td style="text-align: left;">趋势分析、告警</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Meta Logs</strong> (TraceID, Status)</td>
<td style="text-align: left;">100%</td>
<td style="text-align: left;">ES/ClickHouse</td>
<td style="text-align: left;">3个月</td>
<td style="text-align: left;">检索、统计成功率</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Full Payload</strong> (Prompt, Response)</td>
<td style="text-align: left;">1-5% (Head) <br> 100% (Error)</td>
<td style="text-align: left;">S3/OSS (Cold)</td>
<td style="text-align: left;">2周</td>
<td style="text-align: left;">深度调试、回放</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Binary</strong> (Audio/Image)</td>
<td style="text-align: left;">0.1%</td>
<td style="text-align: left;">S3 Deep Archive</td>
<td style="text-align: left;">3天</td>
<td style="text-align: left;">极少数Case分析</td>
</tr>
</tbody>
</table>
<h3 id="pii-scrubbing">隐私脱敏 (PII Scrubbing)</h3>
<p>LLM 的 Prompt 经常包含 PII。在写入磁盘前，必须经过 <strong>Scrubber Pipeline</strong>。</p>
<ul>
<li><strong>Regex Replacement</strong>: 替换手机号、邮箱、身份证。</li>
<li><strong>Named Entity Redaction</strong>: 使用小模型（如 BERT-NER）识别并替换人名/地名。</li>
<li><strong>Token Isolation</strong>: 将敏感数据（Sensitive Data）单独存储在加密库，日志中只留 <code>ref_id</code>。只有持有特定私钥的审计员才能解开 <code>ref_id</code>。</li>
</ul>
<hr />
<h2 id="137">13.7 可视化：从后台到前台</h2>
<p>可观测性不仅给开发者看，也可以部分暴露给用户（Explainability）。</p>
<h3 id="_3">开发者面板</h3>
<ul>
<li><strong>Gantt Chart</strong>: 瀑布图展示 RAG、Tool、LLM 的并行与串行关系。</li>
<li><strong>Token Replay</strong>: 在时间轴上逐个 Token 重新打字，配合当时的 State 变化。</li>
</ul>
<h3 id="thinking-process">用户可见的 "Thinking Process"</h3>
<ul>
<li>将后端的 <code>Effect Start/End</code> 事件映射为 UI 上的状态指示器。</li>
<li><em>Example</em>:<ul>
<li><code>[Effect: Retrieve]</code> -&gt; UI 显示 "正在查阅文档库..."</li>
<li><code>[Effect: Python]</code> -&gt; UI 显示 "正在计算数据..."</li>
<li><code>[Effect: Error]</code> -&gt; UI 显示 "搜索超时，正在重试..."</li>
</ul>
</li>
</ul>
<hr />
<h2 id="_4">本章小结</h2>
<ol>
<li><strong>Event Stream 是单一事实来源</strong>：State 只是 Event 的投影，Log Event 等于 Log Everything。</li>
<li><strong>Context 必须并在流中传递</strong>：解决异步流 Trace 断裂的问题。</li>
<li><strong>Mock 也就是 Replay</strong>：通过截 Effect 执行器，配合日志中的历史回执，实现无需真实后端的确定性回放。</li>
<li><strong>指标要关注“浪费”</strong>：在实时 Agent 中，被 Cancel 的计算、无效的 Retrieve 是优化重点。</li>
</ol>
<hr />
<h2 id="_5">练习题</h2>
<h3 id="_6">基础题</h3>
<ol>
<li><strong>日志字段设计</strong>
设计一个 <code>ToolCallEvent</code> 的 JSON 结构。要求：如果该工具调用失败了，我能通过这个日志知道它是第几次重试（Retry Count），以及它属于哪一轮对话（Turn ID）。</li>
</ol>
<details>
<summary>参考答案</summary>
<div class="codehilite"><pre><span></span><code><span class="p">{</span>
<span class="w">  </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;TOOL_CALL&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;trace_id&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;sess-123-turn-5&quot;</span><span class="p">,</span><span class="w"> </span><span class="c1">// 包含 Session 和 Turn 信息</span>
<span class="w">  </span><span class="nt">&quot;span_id&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;call-retry-2&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;ts&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">1620000000</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;payload&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;tool&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;stock_api&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;params&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="nt">&quot;symbol&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;AAPL&quot;</span><span class="p">},</span>
<span class="w">    </span><span class="nt">&quot;meta&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nt">&quot;turn_id&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;retry_count&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="c1">// 第2次重试</span>
<span class="w">      </span><span class="nt">&quot;max_retries&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;reason_for_retry&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Previous timeout&quot;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

</details>
<ol start="2">
<li><strong>耗时计算</strong>
在 FRP 中，用户输入 "Hello" 触发了 LLM 请求。
Event A: <code>UserInput</code> (ts: 100)
Event B: <code>LLMStart</code> (ts: 150)
Event C: <code>LLMFirstToken</code> (ts: 300)
Event D: <code>LLMEnd</code> (ts: 600)
请计算：(1) 系统处理延迟 (Overhead) (2) 首字延迟 (TTFT) (3) 生成速度 (假设生成了 30 tokens)。</li>
</ol>
<details>
<summary>参考答案</summary>
<p>(1) <strong>System Overhead</strong>: Event B - Event A = 150 - 100 = 50ms (包含 Debounce、Prompt 组装耗时)
(2) <strong>TTFT</strong>: Event C - Event A = 300 - 100 = 200ms (用户视角的首字延迟)
(3) <strong>Speed</strong>: 30 tokens / (600 - 300)ms = 30 / 0.3s = 100 tokens/sec</p>
</details>
<h3 id="_7">挑战题</h3>
<ol start="3">
<li>
<p><strong>处理回放偏离 (Divergence)</strong>
你在 Debug 一个线上的 Bug，下载了日志进行回放。但是你本地的代码比线上版本新，修改了 Prompt 模板（加了一句 System Instruction）。
当你运行回放时，Agent 生成的 Prompt Hash 与日志里的不一致。
请问：</p>
</li>
<li>
<p>回放系统应该报错停止，还是继续？</p>
</li>
<li>如果继续，后续的 Mock Tool Call 能否匹配上？</li>
<li>如何设计一种“模糊匹配”机制应对轻微的代码变更？</li>
</ol>
<details>
<summary>参考提示</summary>
<ol>
<li><strong>默认策略</strong>：应该报警 (Warn) 但允许尝试继续。因为 Debug 的目的往往就是验证“新代码能否修复旧 Bug”。</li>
<li><strong>匹配问题</strong>：如果 Prompt 变了，LLM 的输出（在 Mock 模式下）可能就对不上了。比如日志里 LLM 说“调用工具 A”，但新 Prompt 导致 LLM 说“调用工具 B”。此时必须停止回放，因为路径分叉了。</li>
<li><strong>模糊匹配</strong>：<ul>
<li>对于 Tool Call Mock，不要仅匹配 Prompt Hash。应该匹配 <strong>"Tool Name + Arguments"</strong>。</li>
<li>即使 Prompt 变了，只要 LLM 依然决定调用同一个工具且参数相同，回放就可以继续。这增强了回放的鲁棒性。</li>
</ul>
</li>
</ol>
</details>
<ol start="4">
<li><strong>隐私与长上下文的冲突</strong>
你需要记录 Agent 的完整上下文以便 Debug "遗忘" 问题，但 Context 中包含了用户上传的机密 PDF 内容（10MB 文本）。
如果全量记日志，存储成本爆炸且有合规风险。如果不记，Debug 时不知道 PDF 内容是什么。
请设计一个方案解决这个问题。</li>
</ol>
<details>
<summary>参考提示</summary>
<p><strong>方案：Content-Addressable Storage (CAS) + Zero-Knowledge Logs</strong></p>
<ol>
<li><strong>PDF 解析阶段</strong>：将 PDF 文本提取后，计算 Hash (SHA-256)。</li>
<li><strong>存储</strong>：将 PDF 文本存入一个安全的、有 TTL（自动过期）的 Blob 存储，Key 就是 Hash。</li>
<li><strong>日志记录</strong>：在 Event Log 中，只记录 <code>content_hash: "sha256:..."</code> 和 <code>content_length: 50000</code>。</li>
<li><strong>回放</strong>：<ul>
<li>如果 Blob 还在（有效期内），回放器自动下载内容填充。</li>
<li>如果 Blob 已过期/被删，回放器使用 "Placeholder Text"（如 <code>[CENSORED CONTENT - 5000 tokens]</code>）填充。虽然无法 Debug 具体语义，但可以 Debug Token 预算计算、上下文裁剪逻辑等与具体内容无关的 Bug。</li>
</ul>
</li>
</ol>
</details>
<hr />
<h2 id="gotchas">常见陷阱与错误 (Gotchas)</h2>
<h3 id="1-jsonstringify">1. <code>JSON.stringify</code> 的性能陷阱</h3>
<p><strong>错误</strong>：在主线程的流处理管道中直接同调用 <code>JSON.stringify(huge_state_object)</code>。
<strong>后果</strong>：当 State 包含长对话历史时，序列化可能耗时 10-50ms，这会阻塞事件循环，导致音频处理丢帧或 UI 掉帧。
<strong>修正</strong>：</p>
<ul>
<li>使用 <code>worker_thread</code> 进行日志序列化。</li>
<li>或者使用 <code>Flatted</code> 等库的异步版本。</li>
<li>仅记录 Diff 而非全量 State。</li>
</ul>
<h3 id="2">2. 时间戳混乱</h3>
<p><strong>错误</strong>：在日志分析时，混用了 <code>Event_Created_Time</code> (事件产生的时刻) 和 <code>Log_Written_Time</code> (日志落盘的时刻)。
<strong>后果</strong>：在高并发或网络拥塞下，落盘时间可能滞后几秒，导致分析出的 Latency 指标完全错误。
<strong>修正</strong>：永远信任 Event 内部携带的 <code>timestamp</code> 字段。</p>
<h3 id="3-heisenbug-bug">3. "Heisenbug" (海森堡 Bug)</h3>
<p><strong>错误</strong>：开启详细日志（Debug Mode）时 Bug 消失，关闭时 Bug 复现。
<strong>原因</strong>：通常是因为日志操作本身引入了 I/O 延迟，改变了 <code>race condition</code> 的获胜者。
<strong>修正</strong>：</p>
<ul>
<li>确保日志操作是完全异步的（Fire-and-forget）。</li>
<li>在 FRP 中使用逻辑时钟（Sequence ID）而非物理时间来决定竞态结果（见 Chapter 11）。</li>
</ul>
            </article>
            
            <nav class="page-nav"><a href="chapter12.html" class="nav-link prev">← Chapter 12｜Token Budget 控制：预算就是产品体验</a><a href="chapter14.html" class="nav-link next">Chapter 14｜人类直观 UI（含音效）与后台 Debug 可视化 →</a></nav>
        </main>
    </div>
</body>
</html>