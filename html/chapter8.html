<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <base href="./">
    <title>Chapter 8｜Speculative Exec & Speculative Decoding：让系统“更快也更稳”</title>
    <link rel="stylesheet" href="assets/style.css">
    <link rel="stylesheet" href="assets/highlight.css">
    <script src="assets/script.js" defer></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$']],
                displayMath: [['$$', '$$']],
                processEscapes: false,
                packages: {'[+]': ['noerrors', 'ams']}
            },
            options: {
                ignoreHtmlClass: 'tex2jax_ignore',
                processHtmlClass: 'tex2jax_process'
            },
            loader: {
                load: ['[tex]/noerrors', '[tex]/ams']
            }
        };
    </script>
</head>
<body>
    <div class="container">
        <nav id="sidebar" class="sidebar">
            <div class="sidebar-header">
                <h3>目录</h3>
                <button id="sidebar-toggle" class="sidebar-toggle">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
            </div>
            <div class="sidebar-search">
                <input type="text" id="sidebar-search-input" placeholder="搜索..." autocomplete="off">
            </div>
            <div id="tree-container">
                <nav class="tree-nav" role="tree">
                    <div class="tree-item " >
                        <a href="index.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">《用 FRP（Functional Reactive Programming）搭建 LLM 实时 Agent：从抽象到落地》</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter1.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 1｜问题空间与总体架构：为什么用 FRP</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter2.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 2｜FRP 基础：用事件流描述 Agent</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter3.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 3｜核心运行时：Agent 作为“可组合的反应系统”</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter4.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 4｜Prompt Management：内嵌环境状态播报 + 时间变化</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter5.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 5｜用户异步动作：打断、撤回、改口、多模态输入</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter6.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 6｜工具 / API 调用：失效处理、回退、幂等与隔离</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter7.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 7｜RAG / DB / Python toolcall：把知识管道变成事件流</span>
                        </a>
                    </div>
                
                    <div class="tree-item active" >
                        <a href="chapter8.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 8｜Speculative Exec & Speculative Decoding：让系统“更快也更稳”</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter9.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 9｜Dynamic Batching & 并发：吞吐、延迟与公平性</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter10.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">[Chapter 10｜事件触发器：做一个“类似 VAD”的 Agent Trigger System](chapter10.md)</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter11.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 11｜Race Condition 与一致性：并发世界的“真相维护”</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter12.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 12｜Token Budget 控制：预算就是产品体验</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter13.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 13｜日志持久化与可观测性：Tracing/Replay/Metric 一体化</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter14.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 14｜人类直观 UI（含音效）与后台 Debug 可视化</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter15.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 15｜安全、隐私与治理：让 Agent 可上线、可合规</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter16.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 16｜评测与持续迭代：从“能用”到“好用”</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter17.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 17｜参考实现：一个端到端的 FRP Agent</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter18.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Appendix A｜术语表 & FRP 算子速查 (The Agent Developer's Rosetta Stone)</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter19.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Appendix B｜数据结构与协议：Event/State/Receipt/Trace Schema</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter20.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Appendix C｜测试方法：虚时间、回放与混沌工程</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="CLAUDE.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Untitled</span>
                        </a>
                    </div>
                </nav>
            </div>
        </nav>
        
        <main class="content">
            <article>
                <h1 id="chapter-8speculative-exec-speculative-decoding">Chapter 8｜Speculative Exec &amp; Speculative Decoding：让系统“更快也更稳”</h1>
<h2 id="1">1. 开篇：用“废弃”换取“时间”</h2>
<p>在实时 Agent 系统中，<strong>延迟（Latency）</strong> 是用户体验的头号杀手。传统的“用户输入 -&gt; LLM 思考 -&gt; 工具调用 -&gt; LLM 生成”是一个串行过程，极其缓慢。</p>
<p><strong>投机（Speculation）</strong> 的核心思想是：<strong>不要等确定了再做，而是在“大概率”发生时就提前做。</strong> 如果猜对了，我们赢得时间；如果猜错了，我们丢弃结果（付出计算成本）。</p>
<p>在 FRP（Functional Reactive Programming）架构中，投机机制有着天然的优势：<strong>FRP 极其擅长“取消”和“切换”</strong>。当更准确的意图（Signal）到来时，旧的投机流（Stream）可以被 <code>switchLatest</code> 等算子瞬间切断，确系统状态的一致性，而无需复杂的锁或回调清理逻辑。</p>
<p><strong>本章目标</strong>：</p>
<ol>
<li>区分 <strong>工具投机（Exec）</strong> 与 <strong>解码投机（Decoding）</strong> 的应用场景。</li>
<li>掌握利用 FRP 算子（<code>merge</code>, <code>race</code>, <code>switchLatest</code>）管理并发分支的方法。</li>
<li>学习如何在 UI 上优雅地处理“先猜后改”的显示逻辑。</li>
<li>建立投机机制的成本控制与监控体系。</li>
</ol>
<hr />
<h2 id="2">2. 文字论述</h2>
<h3 id="81-exec-vs-decoding">8.1 两类投机：行动（Exec） vs 解码（Decoding）</h3>
<p>虽然都叫“投机”，但在 Agent 架构中处于不同层级：</p>
<ol>
<li>
<p><strong>Speculative Decoding (Token Level)</strong>:</p>
<ul>
<li><strong>对象</strong>：LLM 的文本生成。</li>
<li><strong>原理</strong>：用一个小模型（Draft Model）快速生成后续 token 的“草稿”，大模型（Verify Model）并行验证。如果验证通过，直接接受；不通过则回滚。</li>
<li><strong>FRP 视角</strong>：这是一个高频的 <code>Event Stream</code> 处理。输入流是 Draft Token Stream，经过一个 <code>VerifyFilter</code> 算子，输出 Verified Token Stream。</li>
</ul>
</li>
<li>
<p><strong>Speculative Execution (Tool/Plan Level)</strong>:</p>
<ul>
<li><strong>对象</strong>：外部工具调用、数据库检索、API 请求。</li>
<li><strong>原理</strong>：在 LLM 还没完全输出 <code>{"tool": "weather", "city": "Beijing"}</code> 之前，根据用户输入的“天气”和上下文“北京”，提前发起查询。</li>
<li><strong>FRP 视角</strong>：这是一个并发的 <code>Effect</code> 管理。我们同时启动多个 <code>Async Task</code>，哪个先返回且符合最终意图，就用哪个。</li>
</ul>
</li>
</ol>
<h3 id="82">8.2 触发条件：什么时候该“赌一把”？</h3>
<p>不能盲目投机，否则资源浪费严重。需要定义触发器（Triggers）：</p>
<ul>
<li><strong>高置信路径（High Confidence Path）</strong>：<ul>
<li>用户输入特定的“热词”（如 "买"、"搜索"、"播放"）。</li>
<li>历史习惯（用户每天早上 9 点都问天气）。</li>
</ul>
</li>
<li><strong>低风险操作（Idempotent/Read-only）</strong>：<ul>
<li><strong>可以投机</strong>：搜索、检索 RAG、读数据库、生成图片预览。</li>
<li><strong>严禁投机</strong>：发送邮件、购买支付删除数据、修改配置。</li>
</ul>
</li>
<li><strong>用户可见延迟预算（Latency Budget）</strong>：<ul>
<li>当系统检测到当前网络延迟很高，或者 LLM 响应变慢时，主动提高投机积极性（Aggressiveness），试图弥补时间。</li>
</ul>
</li>
</ul>
<h3 id="83-speculative-execfrp">8.3 Speculative Exec：FRP 的并发与竞赛</h3>
<p>在 FRP 中，实现投机执行通常涉及 <code>merge</code>（合并流）和 <code>race</code>（竞赛）模式。</p>
<p><strong>ASCII 示意图：预加载（Pre-fetching）模式</strong></p>
<div class="codehilite"><pre><span></span><code>Time --------------------------------------------------------&gt;

User Stream:   &quot;查一下&quot; ---&gt; &quot;北&quot; ---&gt; &quot;京&quot; ---&gt; &quot;天&quot; ---&gt; &quot;气&quot; (完成)
                    |          |
Trigger:            |          +-&gt; [识别意图:可能查天气]

Trigger:            |          +-&gt; [识别意图:可能查天气]
                    |                  |
Speculative Stream: |                  +-&gt; [API: Search &quot;Beijing&quot;] (提前跑)
                    |                                  |
Actual LLM Plan:    |                                  +---------&gt; [Tool Call: Weather(BJ)]
                    |                                                   |

Result Selection:   +---------------------------------------------------+-&gt; (发现缓存中有结果) -&gt; 立即返回
</code></pre></div>

<p><strong>关键算子逻辑</strong>：</p>
<ul>
<li><strong>Fork</strong>：当输入流满足某种模式（Pattern）时，分叉出一个副流去执行副作用。</li>
<li><strong>Cache/Hold</strong>：副流的结果并不直接推给 UI，而是存入一个临时的 <code>Observable&lt;Result&gt;</code> 或缓存池。</li>
<li><strong>Join</strong>：当主流程（LLM 确实发出了工具调用）到达时，先去缓存池检查；如果有，直接通过（0ms 延迟）；如果不一样（猜错了），则丢弃缓存，发起真实请求。</li>
</ul>
<h3 id="84-speculative-decoding">8.4 Speculative Decoding：流式修正</h3>
<p>在 Token 生成层面，FRP 视其为“快速流”和“慢速修正流”的结合。</p>
<div class="codehilite"><pre><span></span><code>Draft Stream (Fast):  A -&gt; B -&gt; C -&gt; D -&gt; E ...
Verify Stream (Slow):      (Check A:OK) -&gt; (Check B:OK) -&gt; (Check C:Fail, real is X)
Final Stream (UI):    A -&gt; B -&gt; [Rollback C,D,E] -&gt; X ...
</code></pre></div>

<p>这要求 UI 组件（Observer）必须支持<strong>回退（Retract）</strong>事件。如果你直接把 token 打印到屏幕上且不可修改，投机解码会导致用户看到乱码闪烁。</p>
<h3 id="85-switchlatest">8.5 一致性与撤销：SwitchLatest 的魔法</h3>
<p><strong>Race Condition</strong> 是投机的大敌：如果投机的请求比真实的请求慢返回，且真实请求已经改变了上下文，怎么办？</p>
<p>FRP 的 <code>switchLatest</code> (或 <code>switchMap</code>) 是终极武器。</p>
<ul>
<li><strong>定义</strong>：将高阶流（Stream of Streams）压平，每当新流产生时，自动取消（Unsubscribe）旧流。</li>
<li><strong>场景</strong>：<ol>
<li>用户输入 "查一下 A 公司的股价"。</li>
<li>系统投机启动 <code>Search(A)</code>。</li>
<li>用户立刻改口（打字飞快）"...不对，是 B 公司"。</li>
<li>系统产生新意图 <code>Search(B)</code>。</li>
<li><code>switchLatest</code> 收到 B 的信号，自动向 <code>Search(A)</code> 的 Promise/Task 发送 Cancel 信号。网络请求中断，资源释放。</li>
</ol>
</li>
</ul>
<h3 id="86">8.6 成本控制：自适应投机</h3>
<p>投机是用 <strong>Compute/Token Cost</strong> 换 <strong>Latency</strong>。这个汇率必须划算。</p>
<p>我们可以引入一个 <strong>Speculation Budget Signal（投机预算信号）</strong>：</p>
<ul>
<li><code>SuccessRate Signal</code>：过去 10 次投机，几次用上了？</li>
<li><code>Cost Signal</code>：当前 Token 消耗速率。</li>
</ul>
<p><strong>Rule of Thumb</strong>：</p>
<ul>
<li>如果 <code>SuccessRate</code> &gt; 80%，加大投机力度（生成更长的草稿，预取更多页面）。</li>
<li>如果 <code>SuccessRate</code> &lt; 20%，进入保守模式，关闭投机。</li>
</ul>
<hr />
<h2 id="3">3. 本章小结</h2>
<ul>
<li><strong>核心权衡</strong>：投机是利用闲置算力或额外成本来对抗延迟。</li>
<li><strong>安全性原则</strong>：只对<strong>无副作用（Idempotent）</strong>或<strong>只读（Read-only）</strong>的操作进行投机执行（Speculative Exec）。</li>
<li><strong>FRP 优势</strong>：利用 <code>switchLatest</code> 实现自动取消，利用 <code>race</code> 实现多路竞争，利用 <code>Stream</code> 抽象处理 Token 的回滚。</li>
<li><strong>UI 配合</strong>：前端必须能处理“撤回”或“即时修正”的信号，以支持投机解码的视觉呈现（如 Ghost text）。</li>
<li><strong>反馈闭环</strong>：必须监控投机的“命中率”和“浪费率”，动态调整策略。</li>
</ul>
<hr />
<h2 id="4">4. 练习题</h2>
<h3 id="_1">基础题</h3>
<p><strong>Q1. 概念辨析</strong>
简述 Speculative Decoding 和 Speculative Execution 的主要区别是什么？它们分别优化了 Agent 的哪部分性能？</p>
<details>
<summary>点击查看提示与答案</summary>
<ul>
<li><strong>提示</strong>：一个关注“怎么说得快”，一个关注“怎么做得快”。</li>
<li><strong>答案</strong>：<ul>
<li><strong>Speculative Decoding</strong>：关注 Token 生成阶段。利用小模型快速生成草稿，大模型验证。优化的是 <strong>Token/sec（生成速度）</strong>。</li>
<li><strong>Speculative Execution</strong>：关注工具使用阶段。在 LLM 决定调用工具前提前执行查询。优化的是 <strong>TTFT (Time To First Token) 或 任务完成总耗时</strong>。</li>
</ul>
</li>
</ul>
</details>
<p><strong>Q2. 安全边界</strong>
以下哪些操作适合进行“投机执行”？为什么？</p>
<ol>
<li>查询天气 API</li>
<li>这里的用户名为 "admin"，尝试删除用户</li>
<li>在 RAG 向量库中检索文档</li>
<li>发送一条 Slack 消息给老板</li>
<li>预加载网页内容的 Summary</li>
</ol>
<details>
<summary>点击查看提示与答案</summary>
<ul>
<li><strong>提示</strong>：考虑操作是否是“只读”的，是否有不可逆的副作用。</li>
<li><strong>答案</strong>：<ul>
<li><strong>适合</strong>：1, 3, 5。因为它们通常是只读的（Read-only）或幂等的（Idempotent），即使猜错了，除了浪费一点带宽和算力，不会破坏系统状态。</li>
<li><strong>不适合</strong>：2, 4。删除数据和发送消息具有明显的副作用（Side Effects）。一旦投机执行了但用户本意并非如此，后果无法撤回。</li>
</ul>
</li>
</ul>
</details>
<p><strong>Q3. FRP 算子选择</strong>
你需要实现一个逻辑：同时向 Google Search, Bing Search, 和 DuckDuckGo 发起相同的查询，<strong>只要有一个</strong>返回了结果，就立即使用该结果，并<strong>取消</strong>另外两个请求。应该使用哪种 FRP 模式？</p>
<details>
<summary>点击查看提示与答案</summary>
<ul>
<li><strong>提示</strong>：这是一个赛跑游戏。</li>
<li><strong>答案</strong>：使用 <code>race</code> (或 <code>amb</code>) 算子。<ul>
<li><code>result$ = race(google$, bing$, ddg$)</code></li>
<li>当第一个流发射据时，<code>race</code> 会自动取消订阅其他未完成的流（前提是流的实现支持 cancellation，如 AbortController）。</li>
</ul>
</li>
</ul>
</details>
<h3 id="_2">挑战题</h3>
<p><strong>Q4. UI 闪烁问题</strong>
在使用 Speculative Decoding 时，小模型生成的草稿可能在 100ms 后被大模型拒绝并重写。如果直接将流接入 UI，用户会看到文字疯狂跳变。请设计一个基于 FRP 的 UI 渲染策略来减轻这种不适感。</p>
<details>
<summary>点击查看提示与答案</summary>
<ul>
<li><strong>提示</strong>：不要把所有数据都视为“已确认”。引入“状态”区分。</li>
<li><strong>答案</strong>：<ol>
<li><strong>数据结构分离</strong>：Event 流中包含 <code>VerifiedText</code> 和 <code>SpeculativeText</code>。</li>
<li><strong>UI 样式区分</strong>：<code>VerifiedText</code> 显示为黑色实体；<code>SpeculativeText</code> 显示为灰色（Ghost text）或带有光标闪烁效果。</li>
<li><strong>Buffer/Debounce</strong>：在视觉上，可以引入极短的 <code>buffer</code>（如 50ms），只有当草稿长度超过 N 个字符或置信度极高时才上屏，减少微小的动。</li>
<li><strong>平滑过渡</strong>：当投机失败回滚时，使用 CSS 动画渐变消失，而不是生硬的文本替换。</li>
</ol>
</li>
</ul>
</details>
<p><strong>Q5. 成本计算器</strong>
假设大模型推理成本为 $C_{big}$/token，小模型为 $C_{small}$/token。投机解码的接受率（Acceptance Rate）为 $\alpha$ (0~1)。草稿长度为 $K$。请给出一个简化的公式，判断在什么情况下开启投机解码是<strong>省钱</strong>的？（注：通常投机解码是为了速度，不一定省钱，但这里我们只讨论成本）。</p>
<details>
<summary>点击查看提示与答案</summary>
<ul>
<li><strong>提示</strong>：比较（纯大模型）与（小模型 + 大模型验证）的期望成本。注意验证过程通常是一次性并行处理 $K$ 个 token。</li>
<li><strong>答案</strong>：<ul>
<li><strong>纯大模型成本</strong>：生成 1 个 token 期望成本 $\approx C_{big}$</li>
<li><strong>投机模式成本</strong>：生成 1 个有效 token，我们需要跑一次小模型生成 $K$ 个草稿（成本 $K \cdot C_{small}$），然后大模型并行验证这 $K$ 个（成本 $\approx C_{big}$，假设并行验证成本接近一次推理）。这 $K$ 个草稿中，期望有 $\alpha \cdot K$ 个被接受。</li>
<li><strong>平均每个有效 Token 的成本</strong>：$\frac{C_{big} + K \cdot C_{small}}{\alpha \cdot K}$</li>
<li><strong>省钱条件</strong>：$\frac{C_{big} + K \cdot C_{small}}{\alpha \cdot K} &lt; C_{big}$</li>
<li>化简得：$\alpha &gt; \frac{1}{K} + \frac{C_{small}}{C_{big}}$</li>
<li><strong>结论</strong>：如果接受率 $\alpha$ 足够高，且小模型足够便宜，才可能在省钱的同时提速。否则，通常是<strong>花钱买时间</strong>。</li>
</ul>
</li>
</ul>
</details>
<p><strong>Q6. 动态投机策略</strong>
设计一个 FRP 管道，根据当前的“系统负载”动态调整投机策略。如果是高峰期（Load High），关闭投机以节省算力；如果是低谷期，开启投机以优化延迟。</p>
<details>
<summary>点击查看提示与答案</summary>
<ul>
<li><strong>提示</strong>：使用 <code>combineLatest</code> 将配置流与业务流结合。</li>
<li><strong>答案</strong>：</li>
</ul>
<div class="codehilite"><pre><span></span><code>LoadSignal = Monitor.cpuLoad$() // 0.0 ~ 1.0
ConfigSignal = LoadSignal.map(load =&gt; load &gt; 0.8 ? &quot;OFF&quot; : &quot;ON&quot;)

UserRequest$
  .withLatestFrom(ConfigSignal)
  .flatMap(([req, mode]) =&gt; {
     if (mode === &quot;ON&quot;) {
        return race(speculativePath(req), standardPath(req));
     } else {
        return standardPath(req);
     }
  })
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="o">*</span><span class="w">   </span><span class="n">利用</span><span class="w"> </span><span class="n n-Quoted">`withLatestFrom`</span><span class="w"> </span><span class="n">读取当前系统状态，动态决定走哪条逻辑分支。</span>
</code></pre></div>

</details>
<hr />
<h2 id="5-gotchas">5. 常见陷阱与错误 (Gotchas)</h2>
<h3 id="51-side-effects">5.1 陷阱：对副作用（Side-effects）进行投机</h3>
<p><strong>错误</strong>：用户输入“帮我订一张机票...”，系统预测用户大概率会订，于是提前调用了 <code>BookingAPI.createOrder()</code>。
<strong>后果</strong>：用户还没确认，钱就扣了，或者订单生成了。
<strong>修正</strong>：<strong>Read/Write 分离</strong>。只能对 <code>searchFlights</code>（查航班）进行投机，绝不能对 <code>bookFlight</code>（订航班）进行投机。在 Tool 定义中增加 <code>isSafe</code> 或 <code>idempotent</code> 标记。</p>
<h3 id="52-cache-poisoning">5.2 陷阱：缓存中毒 (Cache Poisoning)</h3>
<p><strong>错误</strong>：投机执行的结果被写入了全局缓存，但这个结果是基于错误的假设（例如假设用户在“北京”，实际上用户在“南京”）。虽然 UI 上修正了，但后续请求可能读到错误的缓存。
<strong>修正</strong>：投机产生的数据应标记为 <code>tainted</code> 或 <code>speculative</code>，存储在临时的、请求级别的 Scope 中，只有当被“采纳（Accepted）”后，才提升为全局缓存。</p>
<h3 id="53-cancellation-leak">5.3 陷阱：取消失效 (Cancellation Leak)</h3>
<p><strong>错误</strong>：FRP 逻辑中发出了取消信号（Unsubscribe），但底层的 Promise 或 HTTP Client 不支持 AbortSignal。
<strong>后果</strong>：后台依然在跑繁重的任务，虽然前台不显示结果，但服务器资源被耗尽（Resource Exhaustion），导致“拒绝服务（DoS）”。
<strong>修正</strong>：确保所有 Async Effect 都绑定 <code>AbortController</code>。在 FRP 算子的 <code>dispose/teardown</code> 阶段必须触发 <code>abort()</code>。</p>
<h3 id="54">5.4 陷阱：过度投机导致吞吐量下降</h3>
<p><strong>错误</strong>：为了致的单用户延迟，对每个 Token 都做 5 路并发投机。
<strong>后果</strong>：并发数爆炸，导致整个系统的吞吐量（Throughput）断崖式下跌，所有用户的请求都变慢了。
<strong>调试技巧</strong>：监控 <strong>Speculation Efficiency（投机效率）</strong> = (采纳的 Token 数 / 生成的总 Token 数)。如果效率低于 30%，说明在做无用功，应通过 Token Bucket 限制并发。</p>
            </article>
            
            <nav class="page-nav"><a href="chapter7.html" class="nav-link prev">← Chapter 7｜RAG / DB / Python toolcall：把知识管道变成事件流</a><a href="chapter9.html" class="nav-link next">Chapter 9｜Dynamic Batching & 并发：吞吐、延迟与公平性 →</a></nav>
        </main>
    </div>
</body>
</html>