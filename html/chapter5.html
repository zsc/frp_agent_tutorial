<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <base href="./">
    <title>Chapter 5｜用户异步动作：打断、撤回、改口、多模态输入</title>
    <link rel="stylesheet" href="assets/style.css">
    <link rel="stylesheet" href="assets/highlight.css">
    <script src="assets/script.js" defer></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$']],
                displayMath: [['$$', '$$']],
                processEscapes: false,
                packages: {'[+]': ['noerrors', 'ams']}
            },
            options: {
                ignoreHtmlClass: 'tex2jax_ignore',
                processHtmlClass: 'tex2jax_process'
            },
            loader: {
                load: ['[tex]/noerrors', '[tex]/ams']
            }
        };
    </script>
</head>
<body>
    <div class="container">
        <nav id="sidebar" class="sidebar">
            <div class="sidebar-header">
                <h3>目录</h3>
                <button id="sidebar-toggle" class="sidebar-toggle">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
            </div>
            <div class="sidebar-search">
                <input type="text" id="sidebar-search-input" placeholder="搜索..." autocomplete="off">
            </div>
            <div id="tree-container">
                <nav class="tree-nav" role="tree">
                    <div class="tree-item " >
                        <a href="index.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">《用 FRP（Functional Reactive Programming）搭建 LLM 实时 Agent：从抽象到落地》</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter1.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 1｜问题空间与总体架构：为什么用 FRP</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter2.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 2｜FRP 基础：用事件流描述 Agent</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter3.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 3｜核心运行时：Agent 作为“可组合的反应系统”</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter4.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 4｜Prompt Management：内嵌环境状态播报 + 时间变化</span>
                        </a>
                    </div>
                
                    <div class="tree-item active" >
                        <a href="chapter5.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 5｜用户异步动作：打断、撤回、改口、多模态输入</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter6.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 6｜工具 / API 调用：失效处理、回退、幂等与隔离</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter7.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 7｜RAG / DB / Python toolcall：把知识管道变成事件流</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter8.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 8｜Speculative Exec & Speculative Decoding：让系统“更快也更稳”</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter9.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 9｜Dynamic Batching & 并发：吞吐、延迟与公平性</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter10.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">[Chapter 10｜事件触发器：做一个“类似 VAD”的 Agent Trigger System](chapter10.md)</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter11.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 11｜Race Condition 与一致性：并发世界的“真相维护”</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter12.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 12｜Token Budget 控制：预算就是产品体验</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter13.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 13｜日志持久化与可观测性：Tracing/Replay/Metric 一体化</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter14.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 14｜人类直观 UI（含音效）与后台 Debug 可视化</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter15.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 15｜安全、隐私与治理：让 Agent 可上线、可合规</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter16.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 16｜评测与持续迭代：从“能用”到“好用”</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter17.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 17｜参考实现：一个端到端的 FRP Agent</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter18.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Appendix A｜术语表 & FRP 算子速查 (The Agent Developer's Rosetta Stone)</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter19.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Appendix B｜数据结构与协议：Event/State/Receipt/Trace Schema</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter20.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Appendix C｜测试方法：虚时间、回放与混沌工程</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter21.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Appendix D｜部署与运维：配置、灰度、告警与容灾</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="CLAUDE.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Untitled</span>
                        </a>
                    </div>
                </nav>
            </div>
        </nav>
        
        <main class="content">
            <article>
                <h1 id="chapter-5">Chapter 5｜用户异步动作：打断、撤回、改口、多模态输入</h1>
<h2 id="1">1. 开篇段落</h2>
<p>在构建实时 LLM Agent 时，最大的挑战往往不是模型本身，而是<strong>不可预测的人类行为</strong>。
在传统的 Request-Response（回合制）系统中，用户提交输入后，界面通常会被锁定或进入加载状态，直到服务器响应。这是一种“伪实时”。</p>
<p>但在真正的实时系统（Real-time Agent）中，输入通道是<strong>永远开放</strong>的。用户是一个混乱的、高并发的事件源：</p>
<ul>
<li>他们会在 Agent 说话说到一半时插嘴（<strong>打断</strong>）。</li>
<li>他们会盯着屏幕看，一边用鼠标选中文本，一边说“把这个翻译了”（<strong>多模态并发</strong>）。</li>
<li>他们会说“帮我定一张去北京……啊不对，去上海的票”（<strong>流式修正</strong>）。</li>
<li>他们甚至可能在 Agent 执行耗时任务时，点击“取消”按钮，然后立即发起新任务。</li>
</ul>
<p>如果试图用传统的 <code>if-else</code> 或状态机回调来处理这些情况，代码很快就会变成无法维护的“意大利面条”。本章将展示如何利用 FRP 的<strong>时间流（Time Stream）</strong>语义，将这些混乱的用户行为抽象为有序的事件序列，实现优雅的并发控制、自动撤销和上下文对齐。</p>
<p><strong>学习目标</strong>：</p>
<ol>
<li><strong>打断与取消</strong>：掌握 <code>switchLatest</code> 范式，实现“后来者居上”的自动任务切换。</li>
<li><strong>流式修正</strong>：如何处理 ASR（语音识别）的中间态与最终态，以及用户的撤回/编辑操作。</li>
<li><strong>多模态时序对齐</strong>：解决视觉事件（手势/点击）与听觉事件（语音）在物理时间上的不同步问题。</li>
<li><strong>反应式 UX</strong>：利用输入流的元数据（Hover, Focus）驱动预测性执行（Speculative Execution）。</li>
</ol>
<hr />
<h2 id="2">2. 文字论述</h2>
<h3 id="21-string-event">2.1 用户输入流建模：从 String 到 Event</h3>
<p>首先，我们要摒弃“用户输入 = 字符串”的观念。在 FRP 架构中，用户输入是一条永不停歇的<strong>事件流（Event Stream）</strong>。我们需要构建一个高内聚的 <code>UserAction</code> 类型系统。</p>
<h4 id="_1">输入事件分类</h4>
<p>我们在系统中定义的输入事件不仅仅包含内容，还包含<strong>意图状态</strong>：</p>
<ol>
<li>
<p><strong>Ephemeral (瞬态事件)</strong>：</p>
<ul>
<li><code>Typing(char)</code>: 用户正在敲击键盘。</li>
<li><code>AudioFragment(blob)</code>: 麦克风采集到的音频切片。</li>
<li><code>Gaze/Hover(target)</code>: 用户的注意力焦点变化（未确认意图）。</li>
<li><em>处理原则</em>：这类事件通常用于更新 UI 状态（如波形图）、触发预加载或作为上下文缓存，<strong>不直接触发 LLM 推理</strong>。</li>
</ul>
</li>
<li>
<p><strong>Interim (中间态事件)</strong>：</p>
<ul>
<li><code>ASRPartial(text)</code>: 语音识别的实时转录（文字还在变动）。</li>
<li><em>处理原则</em>：用于 UI 展示（灰色文字）和推测性解码（Speculative Decoding），但需警惕“幻觉触发”。</li>
</ul>
</li>
<li>
<p><strong>Commit (提交态事件)</strong>：</p>
<ul>
<li><code>Message(text)</code>: 用户按下回车。</li>
<li><code>ASRFinal(text)</code>: VAD（语音活动检测）判定说话结束，且 ASR 锁定结果。</li>
<li><code>IntentAction(id)</code>: 点击了“生成日报”按钮。</li>
<li><em>处理原则</em>：<strong>这是触发 Agent 思考与执行的唯一信号。</strong></li>
</ul>
</li>
<li>
<p><strong>Meta (元控制事件)</strong>：</p>
<ul>
<li><code>Cancel/Stop</code>: 用户点击停止生成。</li>
<li><code>Edit(originalId, newContent)</code>: 修改历史指令。</li>
<li><code>Undo</code>: 撤销上一步操作。</li>
</ul>
</li>
</ol>
<p><strong>Rule of Thumb</strong>：<strong>输入即信号（Signal），提交即采样（Sample）。</strong> 系统的 Prompt 上下文应该由各种瞬态信号（位置、选区、时间）不断累积而成，而提交事件则是对这些信号的一次“快照”。</p>
<h3 id="22-frp">2.2 “打断”语义：FRP 的核心超能力</h3>
<p>在传统开发中，“打断”意味着你必须手动检查每一个异步操作的句柄，调用 <code>.abort()</code>，清理回调重置 UI。在 FRP 中，这通过算子组合天然实现。</p>
<h4 id="switchlatest"><code>switchLatest</code>：只关心当下</h4>
<p>最核心的算子是 <code>switchLatest</code>（或 <code>switchMap</code>）。它的语义非常符合人类直觉：<strong>“一旦我有新想法，旧想法就不重要了。”</strong></p>
<p>想象两个流：</p>
<ul>
<li><strong>Outer Stream</strong>: 用户意图流（User Intents）。</li>
<li><strong>Inner Stream</strong>: Agent 执行流（Agent Execution，包含思考、工具调用、回复生成）。</li>
</ul>
<p>当用户发出新意图 "B" 时，<code>switchLatest</code> 会自动：</p>
<ol>
<li><strong>退订（Unsubscribe）</strong> 旧意图 "A" 对应的 Inner Stream。</li>
<li><strong>触发清理逻辑</strong>（FRP 库会自动调用流的 dispose/teardown 函数，例如 abort HTTP 请求）。</li>
<li><strong>订阅（Subscribe）</strong> 新意图 "B" 的 Inner Stream。</li>
</ol>
<p><strong>ASCII 示意图：打断与资源释放</strong></p>
<div class="codehilite"><pre><span></span><code>User Intent Stream:
-----(ID:1 &quot;查天气&quot;)--------------------(ID:2 &quot;不对，查股价&quot;)-----&gt;

Derived Execution Stream (switchMap):
     |                                   |
     +--&gt; [ Network Request (Weather) ]  |
          [ Processing...             ]  |
          [ Output: &quot;Beijing is...&quot;   ]  | &lt;--- 这里的后续被切断
               X (Cancelled/Aborted)     +--&gt; [ Network Request (Stock) ]
                                              [ Processing...           ]
                                              [ Output: &quot;AAPL is...&quot;    ]
</code></pre></div>

<h4 id="cancellation-propagation">传播取消（Cancellation Propagation）</h4>
<p>打断不仅仅是停止 LLM 生成 token。FRP 的链式结构能确保取消信号一直传播到底层：</p>
<ul>
<li><strong>UI 层</strong>：停止打字机效果，移除“思考中”动画。</li>
<li><strong>网络层</strong>：<code>AbortController</code> 中断 TCP 连接。</li>
<li><strong>工具层</strong>：如果工具支持（如数据库查询），发送 <code>KILL query</code>；如果工具不支持（如发邮件），则需要在“副作用执行前”再次检查活跃状态（FRP 的 <code>takeUntil</code> 模式）。</li>
</ul>
<h3 id="23-partial-final-vad">2.3 语音流处理：Partial, Final 与 VAD</h3>
<p>语音交互是实时 Agent 的高频场景。难点在于<strong>不稳定性</strong>。</p>
<h4 id="asr">ASR 的抖问题</h4>
<p>流式 ASR 输出是修正性的。
<code>t=1</code>: "我想"
<code>t=2</code>: "我想去"
<code>t=3</code>: "我想去吃"
<code>t=4</code>: "我想去池塘" (ASR 错误猜测)
<code>t=5</code>: "我想去吃饭" (ASR 修正) -&gt; <strong>Final</strong></p>
<p>如果我们在 t=4 时就触发了 Agent（基于激进的推测），用户可能会看到 Agent 正在搜索“池塘”。几毫秒后 ASR 修正为“吃饭”，此时必须<strong>撤回</strong>刚才的搜索。</p>
<p><strong>设计模式：稳定性防抖（Stability Debounce）</strong>
不建议直接使用简单的 <code>debounceTime</code>（会增加延迟）。建议结合<strong>文本相似度</strong>或<strong>状态标记</strong>：</p>
<ol>
<li>维护一个 <code>LastProcessedText</code>。</li>
<li>当新 <code>Partial</code> 到来时，如果与 <code>LastProcessedText</code> 差异过大（语义剧变），且 VAD 显示用户有短暂亦或是，则触发一次轻量级的“意图预判”。</li>
<li>只有收到 <code>Final</code> 事件，才触发完整的 Agent 流程。</li>
</ol>
<h4 id="barge-in">抢话（Barge-in）</h4>
<p>当 Agent 正在 TTS 播报回复时，VAD 检测到用户说话（User Voice Start）。
此时必须立即触发 <code>AudioInterrupt</code> 事件：</p>
<ol>
<li><strong>静音 TTS</strong>：Agent 立即闭嘴。</li>
<li><strong>清空音频缓冲</strong>：防止播放残留内容。</li>
<li><strong>监听新指令</strong>：进入“倾听”模式。</li>
</ol>
<p><strong>注意</strong>：要过滤回声（Echo Cancellation）。如果你没有硬件回声消除，Agent 自己的声音会被麦克风录入，导致 Agent 自己打断自己。这通常需要在音频输入流上做一个 Filter：<code>inputStream.filter(() =&gt; !agentIsSpeaking)</code>。</p>
<h3 id="24-temporal-alignment">2.4 多模态融合：时间窗对齐（Temporal Alignment）</h3>
<p>这是最容易产生 Race Condition 的地方。
场景：用户指着屏幕上的图表（Visual Event），问道：“这个数据为什么异常？”（Audio Event）。</p>
<p>问题在于：</p>
<ol>
<li><strong>先指后说</strong>：手指悬停在图表上，0.5秒后开始说话。</li>
<li><strong>先说后指</strong>：嘴里说着“看这里”，0.5秒后手指才移上去。</li>
<li><strong>说完松手</strong>：说完“这个”之后，手马上移开了。</li>
</ol>
<p>如果简单地使用 <code>withLatestFrom</code>，当 Audio Event 触发时，Visual Event 可能已经变为 <code>null</code>（鼠标移开了），或者还没更新。</p>
<p><strong>解决方案：带记忆的上下文流</strong>
我们需要构建一个<strong>“短期记忆窗口”（Sliding Window Context）</strong>。</p>
<div class="codehilite"><pre><span></span><code>Visual Stream ($hover):
...[Chart A]...[Chart A]...[null]........[Chart B]......&gt;

Voice Stream ($voice):
.............................[Start]..&quot;解释这个&quot;..[End]..&gt;

Aligned Context Strategy:
当 Voice Event 发生时，不要只看 Current Value。
要看 [Voice.Start - 1.0s, Voice.End] 这个时间段内：

1. 出现频率最高的元素？
2. 最后被激活的元素？
3. 或者是通过 LLM 模糊匹配（&quot;这个&quot;指代的是视觉历史中的哪一个）？
</code></pre></div>

<p><strong>FRP 实现思路</strong>：
使用 <code>buffer</code> 或 <code>scan</code> 算子维护一个最近 2 秒的 <code>List&lt;UIEvent&gt;</code>。当语音意图触发时，将这段历史与语音一起打包发给 Agent。</p>
<h3 id="25">2.5 撤回与修改：版本控制与因果一致性</h3>
<p>用户说：“发邮件给张三。” -&gt; Agent 正在写草稿。
用户紧接着：“哎不对，是李四。”</p>
<p>这不仅仅是“打断”，这是<strong>修正（Correction）</strong>。
我们需要引入类似数据库的事务 ID 或 Git 的版本概念：</p>
<ul>
<li><strong>InputRevision</strong>：每个输入不仅仅有 ID，还有 <code>ParentID</code>。<ul>
<li>Event 1: { id: 101, text: "发给张三" }</li>
<li>Event 2: { id: 102, text: "是李四", ref_id: 101, type: "correction" }</li>
</ul>
</li>
<li><strong>Agent 的处理</strong>：<ul>
<li>Agent 收到 Event 2 时，发现它是对 101 的修正。</li>
<li>系统查找 101 产生的副作用（ToolCall: DraftEmail）。</li>
<li>如果副作用未提交，直接丢弃，用新参数重新生成。</li>
<li>如果副作用已提交（邮件已发），Agent 需要自动生成一个<strong>补偿动作（Compensating Action）</strong>，例如“撤回邮件”或“发送更正邮件”。</li>
</ul>
</li>
</ul>
<hr />
<h2 id="3">3. 本章小结</h2>
<ul>
<li><strong>事件驱动</strong>：用户输入不是字符串，是包含生命周期（Ephemeral -&gt; Partial -&gt; Final -&gt; Correction）的复杂事件对象。</li>
<li><strong>打断即切换</strong>：利用 FRP 的 <code>switchLatest</code> 算子，可以将复杂的打断逻辑简化为声明式的流切换，自动处理资源清理和取消传播。</li>
<li><strong>多模态时序</strong>：物理时间的一致性是不可靠的。必须通过“时间窗口”和“缓冲历史”来对齐视觉（手势）与听觉（语音）的意图。</li>
<li><strong>防抖与纠错</strong>：在实时流中，不仅要防抖（Debounce）以减少系统震荡，还要处理修正（Correction），维护操作的因果一致性。</li>
</ul>
<hr />
<h2 id="4">4. 练习题</h2>
<h3 id="_2">基础题</h3>
<p><strong>Q1. 基础打断实现</strong>
构造一个流处理管道：</p>
<ol>
<li>监听用户文本输入 <code>input$</code>。</li>
<li>只有当用户停止输入超过 500ms 后才触发请求（防抖）。</li>
<li>如果在请求处理期间用户又输入了新字符，立即取消旧请求并重新计时。
请用伪代码描述算子链。</li>
</ol>
<details>
<summary>点击展开参考答案</summary>
<p><strong>提示</strong>：结合 <code>debounceTime</code> 和 <code>switchMap</code>。</p>
<p><strong>答案</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="nx">input$</span>
<span class="w">  </span><span class="p">.</span><span class="nx">debounceTime</span><span class="p">(</span><span class="mf">500</span><span class="p">)</span><span class="w"> </span><span class="c1">// 1. 等待静默</span>
<span class="w">  </span><span class="p">.</span><span class="nx">switchMap</span><span class="p">(</span><span class="nx">text</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// 3. 自动切换与取消</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="nx">requestLLM</span><span class="p">(</span><span class="nx">text</span><span class="p">)</span><span class="w"> </span><span class="c1">// 2. 发起请求</span>
<span class="w">          </span><span class="p">.</span><span class="nx">takeUntil</span><span class="p">(</span><span class="nx">cancelSignal$</span><span class="p">)</span><span class="w"> </span><span class="c1">// 可选：显式取消信号</span>
<span class="w">  </span><span class="p">})</span>
<span class="w">  </span><span class="p">.</span><span class="nx">subscribe</span><span class="p">(</span><span class="nx">result</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">updateUI</span><span class="p">(</span><span class="nx">result</span><span class="p">));</span>
</code></pre></div>

<p><code>switchMap</code> (即 <code>map</code> + <code>switchLatest</code>) 是关键，它保证了任何时刻只有一个活跃的 Inner Observable (请求)。</p>
</details>
<p><strong>Q2. 语音状态机</strong>
设计一个流，将原始的 VAD 信号（True/False）转化为三种事件：<code>SpeechStart</code>, <code>SpeechEnd</code>, <code>SpeechInterrupt</code>。其中 <code>SpeechInterrupt</code> 仅在 Agent 正在说话（<code>agentSpeaking$ == true</code>）且检测到 VAD 为 True 时触发。</p>
<details>
<summary>点击展开参考答案</summary>
<p><strong>提示</strong>：需要组合 <code>vad$</code> 和 <code>agentSpeaking$</code> 两个流。</p>
<p><strong>答案</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="nx">vad$</span>
<span class="w">  </span><span class="p">.</span><span class="nx">distinctUntilChanged</span><span class="p">()</span><span class="w"> </span><span class="c1">// 只关注状态跳变</span>
<span class="w">  </span><span class="p">.</span><span class="nx">withLatestFrom</span><span class="p">(</span><span class="nx">agentSpeaking$</span><span class="p">)</span><span class="w"> </span><span class="c1">// 获取当前 Agent 状态</span>
<span class="w">  </span><span class="p">.</span><span class="nx">flatMap</span><span class="p">(([</span><span class="nx">isUserSpeaking</span><span class="p">,</span><span class="w"> </span><span class="nx">isAgentSpeaking</span><span class="p">])</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">isUserSpeaking</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">isAgentSpeaking</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nx">Stream</span><span class="p">.</span><span class="k">of</span><span class="p">(</span><span class="s2">&quot;SpeechInterrupt&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;SpeechStart&quot;</span><span class="p">);</span>
<span class="w">          </span><span class="k">return</span><span class="w"> </span><span class="nx">Stream</span><span class="p">.</span><span class="k">of</span><span class="p">(</span><span class="s2">&quot;SpeechStart&quot;</span><span class="p">);</span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="k">return</span><span class="w"> </span><span class="nx">Stream</span><span class="p">.</span><span class="k">of</span><span class="p">(</span><span class="s2">&quot;SpeechEnd&quot;</span><span class="p">);</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">  </span><span class="p">})</span>
</code></pre></div>

<p>注意：<code>SpeechInterrupt</code> 通常需要优先处理，直接路由到音频播放器的 <code>stop()</code> 方法。</p>
</details>
<p><strong>Q3. 简单的撤回逻辑</strong>
用户发送消息后 5 秒内点击“撤回”。如何设计流来处理这个“撤回窗口”？</p>
<details>
<summary>点击展开参考答案</summary>
<p><strong>提示</strong>：发送消息产生的不是由结果，而是一个带有“可撤销句柄”的对象。</p>
<p><strong>答案</strong>：
消息发送流产生一个 <code>PendingAction</code> 对象，放入一个缓冲池。
UI 上的“撤回”按钮触发 <code>undo$</code> 流。
<code>undo$</code> 流携带 <code>messageId</code>，在缓冲池中查找对应的 Action。
如果找到且未超时（&lt;5s）：</p>
<ol>
<li>触发 Action 的 <code>cancel()</code> 方法（如果是 API 请求）。</li>
<li>发出 <code>RemoveMessage</code> 事件更新 UI。
FRP 思路：<code>send$.delay(5000)</code> 作为“不可撤销”的提交点，在 5秒内 <code>undo$</code> 可以阻断该流。</li>
</ol>
</details>
<p><strong>Q4. 输入流合并</strong>
你需要同时监听“语音识别流”和“键盘输入流”。如果用户正在打字，语音识别的结果（可能是背景人声）应该被忽略。如何实现？</p>
<details>
<summary>点击展开参考答案</summary>
<p><strong>提示</strong>：Gate / Filter 模式，利用 <code>combineLatest</code> 或 <code>merge</code> 加状态位。</p>
<p><strong>答案</strong>：</p>
<ol>
<li>创建 <code>isTyping$</code> 信号：<code>keyboard$.map(() =&gt; true).merge(keyboard$.debounce(2000).map(() =&gt; false))</code>。</li>
<li>过滤语音流：</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="nx">validVoice$</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">rawVoice$</span><span class="p">.</span><span class="nx">withLatestFrom</span><span class="p">(</span><span class="nx">isTyping$</span><span class="p">)</span>
<span class="w">  </span><span class="p">.</span><span class="nx">filter</span><span class="p">(([</span><span class="nx">text</span><span class="p">,</span><span class="w"> </span><span class="nx">typing</span><span class="p">])</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="o">!</span><span class="nx">typing</span><span class="p">)</span><span class="w"> </span><span class="c1">// 如果正在打字，丢弃语音</span>
<span class="w">  </span><span class="p">.</span><span class="nx">map</span><span class="p">(([</span><span class="nx">text</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="p">])</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">text</span><span class="p">);</span>
</code></pre></div>

<ol start="3">
<li>最后合并：<code>finalInput$ = validVoice$.merge(keyboard$)</code>。</li>
</ol>
</details>
<h3 id="_3">挑战题</h3>
<p><strong>Q5. 多模态“时光倒流”</strong>
用户先指了一个图表（Visual Event），然后手移开了，2秒后说“刚才那个图表...”。此时 <code>withLatestFrom</code> 取到的是空。
请设计一个 Operator 或逻辑，能够根据语音内容中的关键词（“刚才那个”），回溯过去 5 秒内的 Visual Stream 历史，找到最可能的对象。</p>
<details>
<summary>点击展开参考答案</summary>
<p><strong>提示</strong>：<code>ReplaySubject</code> 结合 <code>Scan</code> 维护历史队列。</p>
<p><strong>答案</strong>：</p>
<ol>
<li>维护一个 <code>visualHistory$</code>，使用 <code>scan</code> 保存过去 5 秒的所有 visual events（带时间戳）。</li>
<li>
<p>当收到语音包含“刚才”、“上一个”等指代词时：
   取出 <code>visualHistory$</code> 的当前值（一个列表）。
   按时间倒序遍历，或者让 LLM 作为一个纯函数 <code>f(history_list, user_query)</code> 来选择最匹配的元素。</p>
</li>
<li>
<p>这种“时序模糊匹配”是多模态 Agent 的核心逻辑之一。</p>
</li>
</ol>
</details>
<p><strong>Q6. 并发编辑冲突解决 (OT 思想)</strong>
两个用户（User A, User B）同时操作同一个 Agent 上下文。A 修改了 Prompt，B 正在根据旧 Prompt 等待回复。
如何利用 FRP 流检测这种冲突并向 B 发出警告？</p>
<details>
<summary>点击展开参考答案</summary>
<p><strong>提示</strong>：利用 Sequence ID 或 State Hash 对比。</p>
<p><strong>答案</strong>：</p>
<ol>
<li>全局状态流 <code>globalState$</code> 每次更新都有一个递增 <code>version</code>。</li>
<li>User B 的请求流发出时，捕获当前的 <code>requestVersion = 10</code>。</li>
<li>当 Agent 准备返回结果给 B 时（可能是流式输出），对比 <code>currentGlobalVersion</code>。</li>
<li>如果 <code>currentGlobalVersion &gt; requestVersion</code>，说明在 B 等待期间状态变了。</li>
<li>在输出流中注入一个 <code>StateMismatchWarning</code> 事件，UI 弹窗提示：“上下文已变更，结果可能过时，是否刷新？”</li>
</ol>
</details>
<p><strong>Q7. 流式工具调用的“后悔药”</strong>
Agent 决定调用一个耗时工具（如“扫描全盘文件”）。工具开始运行了。用户突然说“算了别找了”。
请设计一个端到端的 FRP 链路，确保用户的语音指令能穿透到 Python 解释器或 Shell 进程中杀死该任务。</p>
<details>
<summary>点击展开参考答案</summary>
<p><strong>提示</strong>：Cancellation Token 的全链路传。</p>
<p><strong>答案</strong>：</p>
<ol>
<li>用户语音 "算了" -&gt; 意图识别 -&gt; <code>CancelIntent</code>。</li>
<li>主控制流 <code>agentLoop$</code> 收到 <code>CancelIntent</code>。</li>
<li><code>agentLoop$</code> 是一个 <code>switchLatest</code> 结构，新意图会导致旧的 Observable 被 unsubscribe。</li>
<li>工具执行的 Observable 在 <code>return/dispose</code> 回调中，必须包含清理逻辑：
   - 如果是本地进程：<code>subprocess.kill()</code>
   - 如果是远程 API：发送 HTTP DELETE 或 Cancel 信号。</li>
<li><strong>关键点</strong>：工具封装层必须返回一个带有 dispose 逻辑的 Observable，不能是单纯的 Promise。</li>
</ol>
</details>
<p><strong>Q8. 乐观 UI (Optimistic UI) 的回滚流</strong>
为了极致响应，用户发出指令后，UI 立即假设成功并更新（例如把 todo 项划掉）。但 1 秒后 Agent 返回“操作失败”。
如何用 FRP 处理这种“先斩后奏”及其失败回滚？</p>
<details>
<summary>点击展开参考答案</summary>
<p><strong>提示</strong>：<code>merge</code> 两个流：一个是立即的乐观值，一个是延迟的真实值（可能包含 error。</p>
<p><strong>答案</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="nx">action$</span><span class="p">.</span><span class="nx">flatMap</span><span class="p">(</span><span class="nx">action</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">optimistic</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">Stream</span><span class="p">.</span><span class="k">of</span><span class="p">(</span><span class="ow">new</span><span class="w"> </span><span class="nx">SuccessEvent</span><span class="p">(</span><span class="nx">action</span><span class="p">));</span><span class="w"> </span><span class="c1">// 立即假装成功</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">realRequest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">execute</span><span class="p">(</span><span class="nx">action</span><span class="p">)</span>
<span class="w">        </span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">result</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">ConfirmedEvent</span><span class="p">(</span><span class="nx">result</span><span class="p">))</span><span class="w"> </span><span class="c1">// 真实确认</span>
<span class="w">        </span><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">err</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">Stream</span><span class="p">.</span><span class="k">of</span><span class="p">(</span><span class="ow">new</span><span class="w"> </span><span class="nx">RollbackEvent</span><span class="p">(</span><span class="nx">action</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="p">)));</span><span class="w"> </span><span class="c1">// 失败回滚</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">Stream</span><span class="p">.</span><span class="nx">merge</span><span class="p">(</span><span class="nx">optimistic</span><span class="p">,</span><span class="w"> </span><span class="nx">realRequest</span><span class="p">);</span>
<span class="p">})</span>
</code></pre></div>

<p>Reducer 接收到 <code>SuccessEvent</code> 更新 UI 样式（半透明）；接收到 <code>ConfirmedEvent</code> 变为实心；接收到 <code>RollbackEvent</code> 则恢复原样并报错。</p>
</details>
<hr />
<h2 id="5-gotchas">5. 常见陷阱与错误 (Gotchas)</h2>
<h3 id="51-zombie-state">5.1 幽灵状态 (Zombie State)</h3>
<ul>
<li><strong>现象</strong>：用户打断了 Agent，UI 看起来已经停止了，但后台日志显示 Agent 还在疯狂调用工具，甚至几分钟后突然弹出一个无关的报错。</li>
<li><strong>原因</strong>：FRP流虽然被 unsubscribe 了，但流内部的<strong>副作用（Side Effect）</strong>没有实现正确的清理（Teardown）逻辑。例如，启动了一个 <code>setInterval</code> 或发出了一个没有 <code>AbortSignal</code> 的 <code>fetch</code> 请求。</li>
<li><strong>调试</strong>：检查每一个自定义的 Observable 创建函数（<code>new Observable(...)</code>），确保其返回的 teardown function 能够真正停止正在进行的物理操作。</li>
</ul>
<h3 id="52-out-of-order-arrival">5.2 乱序到达 (Out-of-Order Arrival)</h3>
<ul>
<li><strong>现象</strong>：用户先发了 Short Request (A)，紧接着发了 Long Request (B)。结果 A 先处理完显示了，B 正在处理，突然 A 的结果又覆盖了 B 的 Loading 状态，或者 B 先返回了，A 后返回覆盖了 B。</li>
<li><strong>原因</strong>：没有使用 <code>switchLatest</code> 或 <code>concatMap</code>，而是使用了 <code>mergeMap</code>（并行处理）。导致结果回来的顺序只取决于网络延迟，而非用户意图顺序。</li>
<li><strong>Fix</strong>：对于必须线性的对话流，严禁使用 <code>mergeMap</code>。</li>
</ul>
<h3 id="53-vad">5.3 VAD 切割过碎</h3>
<ul>
<li><strong>现象</strong>：用户说一句话稍微停顿了一下，Agent 就以为说完了开始回答，导致对话变成：“我想要...”“好的！”“...一个苹果。”“明白了！”。</li>
<li><strong>原因</strong>：VAD 的 <code>silence_threshold</code> 时间太短，或者没有配置“语音拼接”策略。</li>
<li><strong>Fix</strong>：<ol>
<li>增大 VAD 阈值（如从 300ms 增至 700ms）。</li>
<li>引入“语义完整性检测”：在 Final 提交前，先用一个小模型（或正则/N-gram）判断句子是否完整。如果不完整，即使 VAD 触发也不提交，而是等待下一个片段（Wait-for-more）。</li>
</ol>
</li>
</ul>
<h3 id="54">5.4 内存泄漏</h3>
<ul>
<li><strong>现象</strong>：Agent 运行一小时后越来越卡。</li>
<li><strong>原因</strong>：在高频事件流（如鼠标移动、音频波形）上使用了 <code>scan</code> 或 <code>buffer</code> 但没有限制大小，导致数组无限膨胀；或者订阅了 EventBus 但在组件销毁时忘记 unsubscribe。</li>
<li><strong>Fix</strong>：<ol>
<li>总是对高频流使用 <code>takeUntil(destroy$)</code> 模式。</li>
<li>给所有 buffering 算子加上最大长度限制（如 <code>buffer(count=100)</code>）。</li>
</ol>
</li>
</ul>
<h3 id="55">5.5 "回声"触发死循环</h3>
<ul>
<li><strong>现象</strong>：Agent 说的话被自己的麦克风听见，被识别为用户输入，Agent 再次回答，限循环。</li>
<li><strong>原因</strong>：缺少 AEC（回声消除）或软件层的“Agent 说话时屏蔽麦克风输入”。</li>
<li><strong>Fix</strong>：在 FRP 链路最前端加一个 Gate：<code>micStream.filter(() =&gt; !speaker.isPlaying)</code>。虽然这会导致 Agent 说话时无法被打断（半双工），但比死循环要好。完美的方案需要硬件 AEC 或基于原始音频数据的减法处理。</li>
</ul>
            </article>
            
            <nav class="page-nav"><a href="chapter4.html" class="nav-link prev">← Chapter 4｜Prompt Management：内嵌环境状态播报 + 时间变化</a><a href="chapter6.html" class="nav-link next">Chapter 6｜工具 / API 调用：失效处理、回退、幂等与隔离 →</a></nav>
        </main>
    </div>
</body>
</html>